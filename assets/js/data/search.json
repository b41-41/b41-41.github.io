[ { "title": "prevent app freezes when use JSON.parse", "url": "/posts/TIL-prevent_JSON_parse_stop_app/", "categories": "TIL, JavaScript", "tags": "", "date": "2023-05-19 00:00:00 +0900", "snippet": "use JSON.parse Parse json to an object or value. but, Sometimes value to pars is not json. so, JSON.parse code causes error Use try catch to prevent apps from stopping at that time.exampleconst...", "content": "use JSON.parse Parse json to an object or value. but, Sometimes value to pars is not json. so, JSON.parse code causes error Use try catch to prevent apps from stopping at that time.exampleconst parseJSON = (str) =&gt; { try { return JSON.parse(str); } catch { console.error(\"str is not JSON::\", str); return ''; //return empty string; }}Reference 째스터, [JavaScript] JSON.parse 사용 시 Error 방지, https://ramdajs.com/docs/#compose, 2018.11.01 mdn web docs, JSON.parse(), https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse, accessed 2023.05.19" }, { "title": "type of R.compose", "url": "/posts/TIL-ramda_compose_type/", "categories": "TIL, TypeScript, Ramda.js", "tags": "", "date": "2023-05-18 00:00:00 +0900", "snippet": "Type of R.compose Type declaration is Union type. The first is the input value (argument). From the second, specify the type in the order of function 1 and function 2 (function 1, 2 is return ty...", "content": "Type of R.compose Type declaration is Union type. The first is the input value (argument). From the second, specify the type in the order of function 1 and function 2 (function 1, 2 is return type)exampleR.compose&lt;[{[key: string]: number}], number, number, &gt;(\t(val) =&gt; val + 1,\tR.propOr(0, ['a']))({a: 1, b: 2});Reference ramda Documentation, compose(), https://ramdajs.com/docs/#compose, Accessed 2023.05.18 @types/ramda, https://www.npmjs.com/package/@types/ramda" }, { "title": "String.prototype.padStart(), object key에 변수 넣기", "url": "/posts/TIL-podStart_objectKey-0230214/", "categories": "TIL, JavaScript", "tags": "", "date": "2023-02-14 00:00:00 +0900", "snippet": "String.prototype.padStart()- 문자열 시작을 다른 문자열로 채워서 정해진 길이를 만족하는 새로운 문자열 반환- `String.podStart(문자길이(number), 채울 문자(string)`- 예) ``` const three = '3'; const hour = three.padStart(2, '0...", "content": "String.prototype.padStart()- 문자열 시작을 다른 문자열로 채워서 정해진 길이를 만족하는 새로운 문자열 반환- `String.podStart(문자길이(number), 채울 문자(string)`- 예) ``` const three = '3'; const hour = three.padStart(2, '0'); console.log(hour); //결과 : 03 ```- padEnd()를 사용하면 오른쪽(끝부분)부터 문자가 채워진다.object key에 변수 넣는 방법- 변수를 []로 감싼다.- (es6부터 지원)- 예) ``` const getKey = '1'; const obj = {[getKey]: 1}; console.log(obj); //결과 : {'1': 1} ```Reference mdn web docs, String.prototype.padStart(), https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/padStart, 2022.12.29 (Accessed 2023.02.14)" }, { "title": "useWorker() - React 밖에서 따로 코드를 실행", "url": "/posts/TIL-useWorker-230109/", "categories": "TIL, JavaScript, React", "tags": "", "date": "2023-02-09 00:00:00 +0900", "snippet": "Web Woker- Web Worker는 브라우저에서 JavaScript 코드를 별도의 스레드에서 실행할 수 있도록 해주는 기술. [mdn using web wokers Link](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)useWorker- ht...", "content": "Web Woker- Web Worker는 브라우저에서 JavaScript 코드를 별도의 스레드에서 실행할 수 있도록 해주는 기술. [mdn using web wokers Link](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers)useWorker- https://github.com/alewin/useWorker- Web Worker를 쉽게 사용할 수 있게 만든 Hook ``` $npm install --save @koale/useworker ```장점 - 메인 스레드와 별도의 스레드에서 코드를 실행할 수 있게 됨 (마치 멀티 스레드처럼) - React 생명주기와 상관없이 외부 코드를 실행시킬 수 있으므로 더 다양한 코딩이 가능. - 계산, 데이터 처리 같은 작업을 병렬적으로 실행시킬 수도 있음. (애플리케이션의 속도 향상도 가능하다.) ### 단점 - 잘못 사용하면 오히려 이상한 코드가 될 수도 있음. (너무 많이 사용해서 React의 장점을 살리지 못한다던지...)예시import React from \"react\";import { useWorker } from \"@koale/useworker\";const numbers = [...Array(5000000)].map(e =&gt; ~~(Math.random() * 1000000));const sortNumbers = nums =&gt; nums.sort();const Example = () =&gt; { const [sortWorker] = useWorker(sortNumbers); const runSort = async () =&gt; { const result = await sortWorker(numbers); // non-blocking UI console.log(result); }; return ( &lt;button type=\"button\" onClick={runSort}&gt; Run Sort &lt;/button&gt; );}; useWorker 함수를 호출할 때, sortNumbers 함수를 전달하여 sortWorker라는 이름의 Worker를 생성 버튼을 클릭했을 때 runSort 함수를 실행해서 sort 계산을 외부로 돌리는 예제Reference mdn web docs, Using Web Workers, hhttps://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers, 2023.1.13 alewin/useWorker github, https://github.com/alewin/useWorker, 2023.2.9 Access" }, { "title": "Promise.race(), Promise.allSettled(), Iterable", "url": "/posts/TIL-blabla-230104/", "categories": "TIL, JavaScript", "tags": "", "date": "2023-01-04 00:00:00 +0900", "snippet": "들어가기- 익숙하지 않았던 Promise 메서드 둘과 IterablePromise.race()- parameter로 iterable이 들어감- iterable 안에 있는 Promise 중에 가장 먼저 완료된 것을 실행 혹은 거부 함.Promise.allSettled()- parameter로 iterabled이 들어감- iterable 안에 있는 모든 ...", "content": "들어가기- 익숙하지 않았던 Promise 메서드 둘과 IterablePromise.race()- parameter로 iterable이 들어감- iterable 안에 있는 Promise 중에 가장 먼저 완료된 것을 실행 혹은 거부 함.Promise.allSettled()- parameter로 iterabled이 들어감- iterable 안에 있는 모든 Pormise가 실행 혹은 거부된 후 결과값 객체를 반영```const promise1 = Promise.resolve(3);const promise2 = new Promise((resolve, reject) =&gt; setTimeout(reject, 100, 'foo'));const promises = [promise1, promise2];Promise.allSettled(promises).then((results) =&gt; results.forEach((result) =&gt; console.log(result.status)));// expected output:// \"fulfilled\"// \"rejected\"```Iterable- 반복 가능한 객체 (Iterable Object)- es2015에서 도입 - 생성자 중 iterable 객체를 만들어내는 생성자는 다음과 같음. - `String`, `Array`, `TypedArray`, `Map`, `Set`Reference mdn web docs, Promise.allSettled(), https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled, 2022.12.29 mdn web docs, Promise.race(), https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/race, 2022.12.29 [Iterable JavaScript로 만나는 세상, https://helloworldjavascript.net/pages/260-iteration.html, 2021.9](https://helloworldjavascript.net/pages/260-iteration.html) " }, { "title": "타입 표명, prettier 설정 있는 곳만 적용하기", "url": "/posts/assertion_prettier-221207/", "categories": "TIL, TypeScript, Prettier", "tags": "", "date": "2022-12-07 00:00:00 +0900", "snippet": "들어가기 타입스크립트에서 as를 사용하는 경우가 가끔 있었는데 어떻게 부르는 지는 몰랐다. 간단 정리… 가끔 prettier 설정이 안 되어 있는 프로젝트에서 나의 vscode prettier 익스텐션 때문에 PR올릴 때 코드 스타일이 달라지는 경우가 있었다.. 이것도 정리..타입 표명 as는 assertion이라고 읽음. assertion 주...", "content": "들어가기 타입스크립트에서 as를 사용하는 경우가 가끔 있었는데 어떻게 부르는 지는 몰랐다. 간단 정리… 가끔 prettier 설정이 안 되어 있는 프로젝트에서 나의 vscode prettier 익스텐션 때문에 PR올릴 때 코드 스타일이 달라지는 경우가 있었다.. 이것도 정리..타입 표명 as는 assertion이라고 읽음. assertion 주장이라는 의미 책에서는 타입 표명이라고 번역됨Prettier 설정 파일 있는 프로젝트만 적용하기 prettier 설정 페이지에 들어가서 Require Config 설정 켜기Reference Typescript Deep Dive (번역 프로젝트), 타입 표명(Type Assertion), 2022.12.7 열람 TE$$ERACT, Prettier 설정 파일이 있을 때에만 적용하기, 2022.6.19" }, { "title": "Conventional Commit, Variable Name Case (변수명 케이스), Array.isArray()", "url": "/posts/TIL-conventional_commits-221201/", "categories": "TIL, JavaScript, Git", "tags": "", "date": "2022-12-01 00:00:00 +0900", "snippet": "들어가기 예전에 커밋 컨벤션에 대해서 정리한 적이 있었다. 사실 그때 chore에 대해서 시스템적인 작업을 할 때 쓴다고 생각을 했다. 하지만 chore의 뜻은 잡일이므로 파일을 삭제하거나, 그 외의 기타 작업할 때 사용한다. 느낌으로 알 때와 달랐던 커밋 컨벤션, 사이트에서 다시 봤다. (Conventional Commit)Convention...", "content": "들어가기 예전에 커밋 컨벤션에 대해서 정리한 적이 있었다. 사실 그때 chore에 대해서 시스템적인 작업을 할 때 쓴다고 생각을 했다. 하지만 chore의 뜻은 잡일이므로 파일을 삭제하거나, 그 외의 기타 작업할 때 사용한다. 느낌으로 알 때와 달랐던 커밋 컨벤션, 사이트에서 다시 봤다. (Conventional Commit)Conventional Commit https://www.conventionalcommits.org/ 커밋 메시지의 규칙을 간단하게 제공 자주 쓰는 부분 정리 feat: : 기능 개발 (ex: feat: add a membership registration function) chore: : 잡일 (삭제, 환경변수 변경, 지원 버전 변경 등등…) (ex: chore: delete unused components) docs: : 본문 없는 커밋 메시지 fix: : 수정 (ex: fix: fix bug) ci: : CI/CD (ex: ci: github action deployment settings) style: : 스타일링, 마크업 (ex: style: apply moving animation style) refector: : 리팩토링 (코드 정돈) (ex: refector: code refactoring)) test: 테스트 코드 (ex: Add jest rate utility test code) Variable Name Case 예전에도 정리한 적이 있지만, 다시 한 번 정리 기본 이름 : my name is b41 Camel case : myNameIsB41 Parscal case : MyNameIsB41 Snake case : my_name_is_b41 Title case : My Name Is B41 Upper case : MY NAME IS B41 Array.isArray() isArray의 파라미터로 오는 값이 array가 맞는지 판별 boolean으로 returnconst arr = [];const notArr = 'array';Array.isArray(arr);//return trueArray.isArray(notArr);//return falseReference jawira, https://github.com/jawira/case-converter, 2022.6 Conventional Commits, 2022.4 mdn web docs, Array.isArray() , 2022.11.7" }, { "title": "Nullish Coalescing operator (??) & Falsy", "url": "/posts/TIL-nullish,falsy-221129/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-11-29 00:00:00 +0900", "snippet": "들어가기 물음표 두 개를 사용하는 Nullish coalescing operator(널 병합 연산자) Falsy (거짓같은 값) 전자는 모르고 있었고 후자는 단어를 모르고 있었다. 정리하자Nullish coalescing operator (null 병합 연산자) const check = 0 ?? 7이라면 result는 ‘0’이다. 왼쪽 연산...", "content": "들어가기 물음표 두 개를 사용하는 Nullish coalescing operator(널 병합 연산자) Falsy (거짓같은 값) 전자는 모르고 있었고 후자는 단어를 모르고 있었다. 정리하자Nullish coalescing operator (null 병합 연산자) const check = 0 ?? 7이라면 result는 ‘0’이다. 왼쪽 연산자(operator)가 null or undefined일 때만 오른쪽 연산자를 반환한다. 아니면 왼쪽 연산자를 반환하는 논리 연산자라고 한다. 비슷한 문법으로 논리 연산자 OR(||)이 있는데 ||은 Falsy값 기준으로 반환하기 때문에 0, [] 같은 경우에도 왼쪽 연산자를 없는 값으로 간주하여 오른쪽 연산자를 반환하게 된다.console.log (0 ?? 7);//expected output : 0console.log (0 || 7);//expected output : 7Falsy JavaScript에서 boolean으로 체크했을 때 false가 나오는 값을 이야기한다. 0, -0, 0n, \"\", null, undefined, Nan (en-US)이 Falsy에 해당한다. 반대 되는 단어는 Truthy라고 한다. (boolean으로 체크할 때 true가 나오는 값)Reference mdn web docs, Nullish coalescing operator, 2022.11.1 mdn web docs, 거짓같은 값, 2022.11.26" }, { "title": "회고 방법들... (난 5F로)", "url": "/posts/TIL-Retrospect-221127/", "categories": "TIL, Work", "tags": "", "date": "2022-11-27 00:00:00 +0900", "snippet": "들어가기 이전 회사에서 PL께서 애자일 방식으로 프로젝트를 진행해 주셔서 첫 직장부터 배운 점이 많았는데 그 중에 특히 회고 부분이 아주 마음에 들었다. 상황에 따라서 KPT, 4L 방법으로 나눠서 회고를 진행했었고, 검색해보니 애자일의 다른 회고 방식도 많이 있었다. 매주 시작할 때마다 Notion에 할 일을 써 놓고 체크하며 진행하고 있는데,...", "content": "들어가기 이전 회사에서 PL께서 애자일 방식으로 프로젝트를 진행해 주셔서 첫 직장부터 배운 점이 많았는데 그 중에 특히 회고 부분이 아주 마음에 들었다. 상황에 따라서 KPT, 4L 방법으로 나눠서 회고를 진행했었고, 검색해보니 애자일의 다른 회고 방식도 많이 있었다. 매주 시작할 때마다 Notion에 할 일을 써 놓고 체크하며 진행하고 있는데, 최근에 회고 항목을 추가했다. 회고를 잘 하고 싶은데 Inflearn에 좋은 글이 있어서 정리(복붙?)해 두려고 한다.회고 방법들… KPT Keep (프로젝트에서 만족했고, 앞으로의 업무에서 지속하고 싶은 부분) Problem (프로젝트에서 부정적인 요소로 작용했거나 아쉬웠던 점) Try (Problem에 대한 해결 방식으로 다음 프로젝트에서 시도해볼 점) 위 관점에서 돌아보며 다음 액션 아이템을 도출할 때 사용하는 회고 템플릿이라고 한다. 5F Fact (사실: 무슨 일이 있었나?) Feeling (느낌: 무슨 느낌이 들었나?) Finding (배운 점: 어떤 인사이트를 얻었나?) Future action (향후 행동: 앞으로 무엇을 해야 할까?) Feedback (피드백: 앞서 정한 향후 행동을 실천해본 뒤, 이에 대해 어떤 피드백을 받았나?) 개인이 한 활동을 회고할 때 시간 순서대로 정리할 수 있어서 유용하다고 한다. 4L(4Ls) Liked (좋았던 점) Lacked (아쉬웠던 점) Learned (배운 점) Longed for (앞으로 바라는 점) 느낀 점들을 중심으로 회고하며 진행 과정에서 중간 점검을 할 때 좋을 것 같다고 한다. PMI Plus (좋았던 점) Minus (아쉬웠던 점) Interesting (흥미로운 점) 회고를 해 보고 나서 느낀 점 그 전에는 템플릿이 없이 회고를 해서 내용이 정신없는 듯한 느낌이 있었는데, 5F 방법으로 회고를 하고 나서 다음 해야할 일을 바로 정리할 수 있게 되었다. 처음으로 이번 주에 일어난 일들과, 느낌들을 정리하며 일의 과정에 대해서 객관적으로 생각해 보았고, 계획없이 일할 때 집중이 잘 안되고 계획이 흐지부지되 버리는 일이 많이 있는데, 이번 주에 배웠던 점과 다음 주에 이어서 할 일에 대해서 정리하면서 끝내지 않으면 안 될 일에 대해서 생각해보고 더 노력할 수 있도록 바뀐 것 같다. 지난 주 피드백을 하면서 나의 부족한 점과 게을렀던 점을 생각하며 반성했고, 앞으로 커리어에서 성장해 나가는데 좋은 역할을 해 줄 것 같아서 회고하는 활동에 매우 만족했다. 👍Reference Inflearn, 개발자의 공유 문화 이모저모 (2) 회고 문화, 2022.2" }, { "title": "i18n 다국어 로케일 파일 관리하는 방법", "url": "/posts/TIL-i18n_221121/", "categories": "TIL, locale, i18n, localize", "tags": "", "date": "2022-11-21 00:00:00 +0900", "snippet": "들어가기 en/common.json처럼 json파일로 보통 관리를 하는데 언어 별로 추가되는 내용이 있을 때마다 관리하기가 복잡하다. 그래서 다른 사람들은 어떻게 해결하고 있는지 인터넷을 통해서 찾아 보았다.방법들 언어팩 관리 프로그램 사용 (윈도우) https://bemeal2.tistory.com/261 장점 E...", "content": "들어가기 en/common.json처럼 json파일로 보통 관리를 하는데 언어 별로 추가되는 내용이 있을 때마다 관리하기가 복잡하다. 그래서 다른 사람들은 어떻게 해결하고 있는지 인터넷을 통해서 찾아 보았다.방법들 언어팩 관리 프로그램 사용 (윈도우) https://bemeal2.tistory.com/261 장점 Excel로 파일을 출력하여 번역가에게 맡길 수 있음. json파일을 읽어서 정리해 줌 단점 외부 프로그램 결국은 배포할 필요가 있음 다국어 파일 관리 Web app https://github.com/hyeonQyu/locale-json-manager 장점 프로젝트 내부에 Dev Dependency로 사용하면 개발 중 바로 관리 페이지를 열어서 확인할 수 있다. 단점 편하게 관리할 수 있지만 dev로 관리할 때만 사용할 수 있다. (결국은 배포 필요) API을 이용한 방법 서버에 DB형태로 번역 데이터를 저장해 놓은 뒤 next.js의 getStaticProps를 활용해서 빌드 시에만 API를 반영하여 업데이트 하도록 함 장점 매번 API를 호출하는 것이 아니기 때문에 리소스 관리에 유용 단점 빌드 중에 API 오류가 나고 그대로 배포가 된다면..?! TOAST (NHN)에서는? https://ui.toast.com/weekly-pick/ko_20210303 google-spreadsheet 라이브러리를 활용. 소스코드에 key를 스캔하여 구글 스프레드 시트에 업로드하여 관리 빌드 시 구글 스프레드 시트에서 번역된 파일을 다시 다운받아서 빌드 장점 엑셀로 관리하는 것과 같기 때문에 번역 맡기기가 편하다. 단점 google spreadsheet API 사용하는 것이 조금 복잡 lokallise https://lokalise.com/ 로컬 라이즈 파일을 관리하거나 API로 번역 내용을 제공해주는 서비스 장점 쉽게 번역 파일을 관리할 수 있음. 단점 유료 Reference 헝그리개발자, Locale File Manager, 2019.3.6 hyeonQyu.log, React.js, Next.js에서 편리하게 다국어 json 파일 관리하기, 2022.7.24 TOAST UI, 국제화(i18n) 자동화 가이드, 2021.3.3, 유동석 Lokalrise, 2022.11.21 열람" }, { "title": "함수형 프로그래밍", "url": "/posts/TIL-functinalProgramming_221105/", "categories": "TIL, 함수형_자바스크립트", "tags": "", "date": "2022-11-05 00:00:00 +0900", "snippet": "함수형 자바스크립트 책 읽으면서 정리하기 함수를 쓴다고 함수형 프로그래밍은 아니다. 함수를 통해 데이터 흐름 제어와 연산을 추상할 수 있게 구현 사이드 이펙트(부수효과)를 방지하고 상태 변이를 감소(Immutableity)시킴 함수형 프로그래밍은 선언적(declarative) 프로그래밍 코드 내부가 어떻...", "content": "함수형 자바스크립트 책 읽으면서 정리하기 함수를 쓴다고 함수형 프로그래밍은 아니다. 함수를 통해 데이터 흐름 제어와 연산을 추상할 수 있게 구현 사이드 이펙트(부수효과)를 방지하고 상태 변이를 감소(Immutableity)시킴 함수형 프로그래밍은 선언적(declarative) 프로그래밍 코드 내부가 어떻게 구현되어 있는지 밝히지 않는 채 연산/작업을 표현하는 방법 printMessage(Hello); //log: Hello Hello, total:5 //로그를 보면 printMessage 함수가 어떤 식으로 구현되어 있는 지 추측은 가능하지만 //세부 구현 방법은 함수를 확인하기 전까지 바로 알 수 없다. 반대 개념은 절차적(procedural), 명령형(imperative) 함수 프로그래밍은 불변성(Immutability), 무상태성(statelessness)를 지향Reference 루이스 아텐시오(2022), 함수형 자바스크립트 - 모던 웹 개발에 충실한 실전 함수형 프로그래밍 안내서, 한빛미디어, 이일웅 역, pp. 23-30 2018.02.09" }, { "title": "웹에서 Apple 로그인 흐름 (백엔드와 함께)", "url": "/posts/TIL-appleLogin_221104/", "categories": "TIL, OAuth, SocialLogin", "tags": "", "date": "2022-11-04 00:00:00 +0900", "snippet": "들어가기 이전에도 애플 로그인을 구현할 때 세팅하는 부분 때문에 애를 먹었지만, 이번에 다시 애플 로그인을 구현하면서 문제가 발생 문제는 기존 애플 로그인에서 사용하던 서비스 아이디 세팅 그대로 기존과 다른 서버의 API에 애플 로그인 결과 토큰을 보냈더니 에러 발생. 그 서버에서 사용하는 애플 로그인 세팅으로 바꾼 후 URI, Redirect ...", "content": "들어가기 이전에도 애플 로그인을 구현할 때 세팅하는 부분 때문에 애를 먹었지만, 이번에 다시 애플 로그인을 구현하면서 문제가 발생 문제는 기존 애플 로그인에서 사용하던 서비스 아이디 세팅 그대로 기존과 다른 서버의 API에 애플 로그인 결과 토큰을 보냈더니 에러 발생. 그 서버에서 사용하는 애플 로그인 세팅으로 바꾼 후 URI, Redirect URL 정보를 추가한 후 해결. 해결하면서 로그인 흐름에 대해서 다시 정리해 봄.Apple 로그인 흐름 백엔드와 함께하는 Apple 로그인 흐름 클라이언트 (사이트) 애플 로그인 요청 미리 애플 개발자 사이트에서 설정해 놓은 값으로 요청 URI입력과 redirect URL입력 부분이 있는데, URI부분에는 [https://(프로토콜)부분](https://부분) 빼고 작성 redirect URL은 실제 Redirect되는 주소 작성 작성 내용이 상이할 시 로그인 창에서 에러 메시지를 띄우게 됨 로그인 후 token 반환 token을 백엔드 서버 API에 전달 백엔드 서버에서 token 유효성 검증 백엔드 서버에서 받은 token으로 로그인 처리 " }, { "title": "Object에 특정 항목 삭제하기 (+destructuring)", "url": "/posts/TIL-object_item_delete.221028/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-10-28 00:00:00 +0900", "snippet": "문제 key a는 1, key b는 2, key c는 3… 이렇게 많은 숫자가 연속적으로 커지는 객체가 있다고 생각해보자 여기에서 key a, b 부분을 빼고 나머지 값만 있는 객체를 새로 하나 만들고 싶다 그럼 어떻게 하면 좋을까? 라는 문제에 답변을 못해서 정리…먼저 mdn에서 살펴보기 delete라는 연산자가 있다고 한다. con...", "content": "문제 key a는 1, key b는 2, key c는 3… 이렇게 많은 숫자가 연속적으로 커지는 객체가 있다고 생각해보자 여기에서 key a, b 부분을 빼고 나머지 값만 있는 객체를 새로 하나 만들고 싶다 그럼 어떻게 하면 좋을까? 라는 문제에 답변을 못해서 정리…먼저 mdn에서 살펴보기 delete라는 연산자가 있다고 한다. const obj = { a: 1, b: 2 }; delete obj.a; // obj = { b : 2 }; 이렇게 하면 간단하게 지워지기는 하는데… strict mode로 들어가면 syntax error가 발생한다.다른 방법 디스트럭처링으로 새로운 object를 변수에 삽입해 주면 된다. const obj = { a: 1, b: 2, c: 3, d: 4 }; const {a, b, ...obj2} = obj; return obj2; //return value is {c: 3, d: 4} 위 예시에서 변수 a의 값을 확인하면 1이 나온다. 그리고, 객체에서 a, b를 디스트럭처링해서 값을 넣어 주었기 때문에 스프레드 연산자로 객체를 출력해주면 a, b를 제외한 나머지 값이 obj2에 남게 된다. 그래서 a, b를 제외한 나머지 key와 value들을 출력할 수 있다.Destructuring (비구조화, 구조 파괴) 객체나 배열의 구조를 파괴하여 변수에 할당하는 것을 의미한다. 가끔 코딩할 때 Object의 값을 쉽게 불러오기 위해서 const {value} = key; 형식으로 사용하는 것이 이에 해당한다. 배열의 경우const arr = [1, 2, 3];const [one, two] = arr;return one;// return value is 1 객체의 경우const obj = {name: 'bin', age: 20, gender: 'm'};const {name, ...obj2} = obj;return obj2;// return value is {age: 20, gender: 'm'}Reference mdn web docs, 구조 분해 할당, 2022.10.14 mdn web docs, delete 연산자, 2022.8.13" }, { "title": "Array.reduce() 활용하기", "url": "/posts/TIL-array_reduce_221027/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-10-27 00:00:00 +0900", "snippet": "들어가기 회사에서 프로젝트를 진행하면서 Array.map()을 주로 사용하고 있다. 다른 개발자 분께서 Array.reduce()를 많이 쓴다고 하시는 걸 들었는데, 보통 누적 값의 합을 계산할 때 쓰는게 아닌가? 라고 생각하다 다른 여러 활용 방안이 있다는 것을 알게 되었다! 정리하자! +_+먼저 Array.reduce() mdn에서 살펴보기...", "content": "들어가기 회사에서 프로젝트를 진행하면서 Array.map()을 주로 사용하고 있다. 다른 개발자 분께서 Array.reduce()를 많이 쓴다고 하시는 걸 들었는데, 보통 누적 값의 합을 계산할 때 쓰는게 아닌가? 라고 생각하다 다른 여러 활용 방안이 있다는 것을 알게 되었다! 정리하자! +_+먼저 Array.reduce() mdn에서 살펴보기 구문은 이렇다고 한다. arr.reduce(callback[, initialValue]) 콜백 안에는 4개의 인자를 가질 수 있다. 누적 값 (acc) 현재 값 (cur) 현재 인덱스 (idx) //옵션 원본 배열 (src) //옵션 보통 1,2번 값을 많이 쓰고 값을 누적해서 더할 때 사용하는 예는 아래와 같다. const arr = [1, 2, 3, 4, 5]; const sum = arr.reduce((acc, cur) =&gt; acc + cur, 0) return sum; // result 15; 이렇게 쓰면 초기 값을 0으로 썼기 때문에 숫자 15로 Return된다~! 이게 일단 기본이고!Array.map()처럼 사용하는 방법 초기 값에 []빈 배열을 넣는다 매번 반복할 때 누적값.push를 통해 계산 후 결과 값을 추가한다. 그럼 map처럼 이용할 수도 있고, filter처럼 이용할 수 있고, array를 원하는 형태로 변경할 수 있다. const arr = [{name: '나', age: 20}, {name: '그대', age: 30}, {name: '우리', age: 25}]; const result = arr.reduce((acc, cur) =&gt; { cur.name &amp;&amp; acc.push(cur.name); }, []); return result; // result ['나', '그대', '우리']; 이렇게 새로운 배열로 반환했다!배열을 객체로 변환하기 초기 값을 빈 객체로 두고 계속 해서 배열의 내용을 누적 시키는 방법이다. const arr = [{name: '나', age: 20}, {name: '그대', age: 30}, {name: '우리', age: 25}]; const result = arr.reduce((acc, cur) =&gt; { const {name, age}= cur; return { ...acc, [name]: age + '살' } }, {}) // result {나: '20살', 그대: '30살', 우리: '25살'} 나, 그대, 우리를 object로 변환시켰다.비동기 순차 실행하기 기본값에 Promise.resolve()을 놓고 누적값.then(다음 프로미스 콜백함수로 실행) 하는 경우 비동기를 순차적으로 실행하는 것을 보장할 수 있음 마치며 프로그램의 구현 방법에는 여러 스타일이 있어서 Array.reduce 거의 사용하지 않고 개발을 했었는데, 앞으로는 많이 애용하게 될 것 같다. 이상~!Reference mdn web docs, Array.prototype.reduce(), 2022.08.29 steemit, reduce를 쓰면서 유용했던 것 몇가지 정리, rouka, 2017 (2022.10.27 열람) Redbit, Using Array.reduce With Objects, Tony Wallace, 2021.12.21 zerocho blog, map, reduce 활용하기, 2018 (2022.10.27 열람)" }, { "title": "Next.js 13 새로운 점!", "url": "/posts/TIL-next_js_13_221026/", "categories": "TIL, Next.js", "tags": "", "date": "2022-10-26 00:00:00 +0900", "snippet": "Next.js 13 새로운 점!들어가기 Next.js 13이 새로 발표되었다! (는 이야기를 CTO님께 전해 들었다.) 간단하게 바뀐 점을 확인!app/ 디렉토리 기존 Next.js에서는 pages/폴더를 통해 간단하게 라우팅을 할 수 있었다. 새로운 13버전에서는 app/폴더를 같이 사용할 수 있다. (베타 버전)app/ 폴더에서 기존 처럼 ...", "content": "Next.js 13 새로운 점!들어가기 Next.js 13이 새로 발표되었다! (는 이야기를 CTO님께 전해 들었다.) 간단하게 바뀐 점을 확인!app/ 디렉토리 기존 Next.js에서는 pages/폴더를 통해 간단하게 라우팅을 할 수 있었다. 새로운 13버전에서는 app/폴더를 같이 사용할 수 있다. (베타 버전)app/ 폴더에서 기존 처럼 pages/ 폴더 처럼 사용하려면 원하는 폴더에 page.js를 만들면 된다. https://mydomain/ 페이지를 만들고 싶으면 pages/page.js를 만들면 되고, https://mydomain/login/ 페이지를 만들고 싶으면 pages/login/page.js를 만들면 된다.레이아웃도 정의할 수 있다. app/login/layout.js폴더에 레이아웃 컴포넌트를 만들면 그 폴더 안에 있는 page에 레이아웃이 삽입되는 것이다. 여러 페이지에 적용하고 싶을 때는 가장 상위 폴더에 넣어주면 된다. 아래처럼! app/website/layout.js 이렇게 넣어두면 app/website/class/page.js, app/website/ticket/page.js (이제 components/layout 폴더 안 만들어도 되겠다~! 오예~!😁) (Next.js로 폴더 구성할 때 Page에 관련된 컴포넌트 분리할 때 pages/board와 components/board 이렇게 폴더가 나뉘어 지게 되어서 복잡했는데 아주 좋다.)스트리밍! (로딩 ) 스트리밍만 봤을 때는 무슨 말인지 잘 이해가 안 되었었는데 app/login/loading.js 처럼 원하는 라우팅 폴더에 loading 파일을 둘 수 있다. 해당 컴포넌트의 콘텐츠가 로딩되는 동안 loading.js 컴포넌트를 출력한다. Instant Loading States라는 페이지에서 자세히 설명해 주고 있는데, layout.js와 page.js아래 하위 항목을 &lt;Suspense&gt;로 감싸주면 적용할 수 있다.&lt;Layout&gt; &lt;Header /&gt; &lt;SideNav /&gt; &lt;Suspense fallback={&lt;Loading /&gt;}&gt; &lt;Page /&gt; &lt;/Suspense&gt;&lt;/Layout&gt;데이터 가져오기 react의 새로운 use 후크가 무려 getStaticProps, getServerSideProps를 대체할 거라고 하는데…. 간단해 보이는데 이 부분은 링크로 대체 (추후 자세히 읽어볼 예정)웹팩보다 700배 빠른 Turbopack 알파 포함! Next.js 13 버전에는 Rust 기반의 터보팩이 포함되어 있다고 하는데, Webpack보다 700배 빠르다고 소개하고 있다. 기존 프로젝트에 적용하면.. 나중에 얼마나 빨라질 지 기대가 된다. 현재는 dev 서버 돌릴 때만 지원하고 나중에 빌드까지 지원할 예정이라고 한다. 요로케 하면 된다. next dev --turbo새로운 next/image alt가 필수로 바뀌었다고 한다. (가끔 넣는 걸 잊어버릴 때가 있는데 오히려 잘 됐다!) 성능 향상이 되었다고 한다.글꼴 시스템 @next/font 구글 글꼴을 쉽게 가져다 쓸 수 있다고 한다.import { Inter } from '@next/font/google';const inter = Inter();&lt;html className={inter.className}&gt; 요로케~! 글꼴 파일 사전 로드, 사용자 정의 글꼴도 물론 지원된다고 한다. const myFont = localFont({ src: './my-font.woff2' });next/link 더 이상 a태그를 같이 쓰지 않아도 된다!!! 오오오오!! &lt;a&gt;태그 이제 안 넣어도 된다! 기존 &lt;a&gt;를 넣었던 &lt;Link&gt;는 이제 next/legacy/image가 되었다. 업그레이드 후 기존 next/link를 사용할 것이라면 import Link from 'next/link'가 아니라 import Link from 'next/legacy/image' 새로운 next/link는 안에 &lt;a&gt;태그를 안 넣어도 된다. (편하다)og 이미지 만들어주는 라이브러리도 추가되었다고 함 @vercel/og (이건 링크로 대체)[https://nextjs.org/blog/next-13#og-image-generation]이제 React 17은 안녕… ㅠㅠ Next.js 13은 React 18.2부터 지원한다고 한다. Node.js도 14로 상향미들웨어 API도 업데이트 되었다고한다.마치며 업데이트를 자주하는 Next.js! 이전보다 편의성이 많이 개선된 것 같고, 메뉴얼도 자세하게 설명되어 있어서 공부하면 할 수록 다른 것에 신경을 덜 쓰고 편하게 개발할 수 있도록 도와주는 좋은 프레임워크라고 다시 한 번 느꼈다. 빨리 Turbopack이 더 적용되어서… 회사 프로젝트의 빌드 속도도 빠르게 해 주기를… 개발자님들 파이팅, 나도 더 잘 사용할 수 있도록 공부하자… 파이팅…Reference Vercel Next.js, Next.js 13, 2020.10.26" }, { "title": "이미 올려버린 커밋 작성자 바꾸기, safari에서 `overflow:hidden`이 적용되지 않는 현상...", "url": "/posts/TIL-git_author_overflow-221018/", "categories": "TIL, Git, CSS", "tags": "", "date": "2022-10-17 00:00:00 +0900", "snippet": "이미 올려버린 커밋 작성자 바꾸기들어가기 집 컴퓨터로도, 회사 컴퓨터로도 열심히 랜딩 페이지 작업을 했다. 이제 모든 작업이 끝나고 메인 브랜치에 merge하려고 하는데 git history에… 내 개인 계정이 올라와 있는 것이다…(헉) 그래서 열심히 검색해서 커밋 작성자(author)를 바꾸고 메인 브랜치에 성공적으로 머지했다.방법 먼저 원...", "content": "이미 올려버린 커밋 작성자 바꾸기들어가기 집 컴퓨터로도, 회사 컴퓨터로도 열심히 랜딩 페이지 작업을 했다. 이제 모든 작업이 끝나고 메인 브랜치에 merge하려고 하는데 git history에… 내 개인 계정이 올라와 있는 것이다…(헉) 그래서 열심히 검색해서 커밋 작성자(author)를 바꾸고 메인 브랜치에 성공적으로 머지했다.방법 먼저 원하는 commit보다 한 단계 이전의 commit을 찾는다. 해당 commit의 해쉬번호를 복사한다. (Github에서 찾아서 복사했다.) git rebase -i를 사용!$git rebase -i @#$@#$@#$@#$@#$@#$@#해쉬넘버@#$@#$@#$@#$ VIM 편집창이 나오면 원하는 commit의 해쉬 번호 앞쪽에 pick이라고 적혀 있는 부분을 e로 바꾼 후 저장, 닫는다 esc -&gt; :wq 작성자를 변경한다. git commit --amend --author\"유저아이디 &lt;이메일&gt;\"$git commit --amend --author\"b41-41 &lt;b41-41@41.kr&gt;\" 다시 VIM 편집창이 나오는데 변경 내용이 맞으면 저장, 닫는다 esc -&gt; :wq rebase를 종료!$git rebase --continue push (기존 커밋을 바꾸기 때문에 force 옵션을 줬다.)$git push blabla -f Reference otrodevym, commit 한 author 변경(작성자 변경) 방법, 2021.05.22safari에서 overflow:hidden이 적용되지 않는 현상…들어가기 랜딩 페이지를 열심히 만들었다. 크롬에서 잘 작동되는 것을 확인 후, safari로 열어보는데 부모 태그 안에 있는 녀석이 자식 태그가 밖으로 튀어나오는 현상이 있었다. overflow:hidden이 적용되어 있는데 왜…?문제는… webkit의 버그라는 블로그 글을 보았다. 부모 태그에 border-radius가 적용되었을 때 발생하는 것 같다. 해결 방법은 relative가 적용되어 있는 부모 태그에 z-index: 0을 주어서 간단하게 해결이 되었다….Reference Sungik Choi, 사파리 overflow:hidden + border-radius 관련 이슈 해결법, 2020.12.18" }, { "title": "git 브랜치 관리할 때 merge와 rebase의 차이", "url": "/posts/TIL-rebase_branch_221014/", "categories": "TIL, Git", "tags": "", "date": "2022-10-14 00:00:00 +0900", "snippet": "들어가기 회사 프로젝트 진행 중 일부 프로젝트에서 협업할 때 merge를 쓰지 않고 rebase를 사용해서 브랜치를 관리하는 것을 봄. 기존 프로젝트를 할 때 merge만 사용했으므로 rebase를 사용하는 이유에 대해서 궁금해짐.merge와 rebase의 차이 merge는 새로운 커밋의 가지가 분기되어서 열심히 쌓이다가 나중에 merge되는 기...", "content": "들어가기 회사 프로젝트 진행 중 일부 프로젝트에서 협업할 때 merge를 쓰지 않고 rebase를 사용해서 브랜치를 관리하는 것을 봄. 기존 프로젝트를 할 때 merge만 사용했으므로 rebase를 사용하는 이유에 대해서 궁금해짐.merge와 rebase의 차이 merge는 새로운 커밋의 가지가 분기되어서 열심히 쌓이다가 나중에 merge되는 기록을 갖게 된다.커밋 1- - 2 - - - 머지 - - - - - 새로운 가지 - rebase는 모든 커밋들을 한 줄로 바꾼다.커밋 1 - rebase했던 내용들 - 커밋2rebase로 브랜치를 관리했을 때 장점 분기처리된 내용이 없기 때문에 모든 커밋 내용이 한 줄로 표시되고 커밋 내용이 직관적으로 잘 보인다.rebase로 브랜치를 관리했을 때 장점 rebase하는 경우 합쳐지는 다른 commit들의 hash값이 변경되어 버리기 때문에 버전관리 측면에서 오히려 안 좋을 수도 있다. (기존에 작업했던 내용이 그대로 있는게 아니고 rebase를 통해서 새로운 커밋이 되는 것이다.)마무리 각자 장단점이 있으므로 프로젝트, 구성원의 의견에 따라서 맞는 git 브랜치 관리 방법을 사용하면 될 것이다. 이 기회에 rebase로 브랜치 관리하는 방법도 봤으니, 잊지 않고 있다가 rebase로 브랜치를 관리하는 방법을 도입하자는 분이 계시면 장단점을 이야기하며 같이 깊은 고민을 한 번 더 나눠봐야 겠다. Reference anonymDev, Merge와 Rebase의 차이점, 2019.03.02" }, { "title": "경로에 따라 움직이는 애니메이션 구현", "url": "/posts/TIL-svg_follow-221011/", "categories": "TIL, CSS", "tags": "", "date": "2022-10-11 00:00:00 +0900", "snippet": "들어가기 주로 백오피스 개발을 담당하다가 팀에서 개발한 다른 제품의 랜딩페이지를 제작하게 되었다. 디자이너님이 준비해 주신 예쁜 애니메이션들 중에 비행기가 날아가는 애니메이션이 있었다. 정해진 경로대로 날아가는 애니메이션을 구현하기 위해 SVG 벡터 경로를 활용하기로 한다. 선을 그려주는 SVG ARTISTA는 회사의 다른 동료 분께서 알려주셨...", "content": "들어가기 주로 백오피스 개발을 담당하다가 팀에서 개발한 다른 제품의 랜딩페이지를 제작하게 되었다. 디자이너님이 준비해 주신 예쁜 애니메이션들 중에 비행기가 날아가는 애니메이션이 있었다. 정해진 경로대로 날아가는 애니메이션을 구현하기 위해 SVG 벡터 경로를 활용하기로 한다. 선을 그려주는 SVG ARTISTA는 회사의 다른 동료 분께서 알려주셨다!선 라인대로 나타나는 애니메이션 그리기 먼저 선을 svg 파일로 다운받는다. SVG ARTISTA에서 svg 경로를 그린다.(혹은 벡터 그래픽 프로그램을 이용해서 선을 그린 후 SVG 포맷으로 익스포트 한다.)비행기 선 따라 이동하기 svg파일의 path부분을 복사한다. 처음 시작하는 좌표 부분을 M0,100 형태로 바꿔준다. offset: path를 사용하여 이동시켜 준다..object{ offset: path('path 내용') auto; animation: moveto 5s ease;}@keyfreams moveto{ 0%{ offset-distance: 0% } 100%{ offset-distance: 100%; }}Reference 어포스트, SVG 벡터 경로(Path)를 따라 이동하는 CSS 애니메이션 만들기, 2020.12.16 SVG ARTISTA, How-to, 2022.10.11 열람" }, { "title": "JSDoc", "url": "/posts/TIL-JSDocs-221010/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-10-10 00:00:00 +0900", "snippet": "JSDoc 주석 및 타입을 적어두고 보여주는 기능을 함. 해당 주석이 달린 함수를 사용하는 부분에 IDE에서 마우스를 올리면 써 두었던 주석이 출력됨/**내용*/ @~~~로 속성을 알려줄 수 있음 @type {string} 타입 @todo 할 일 @deprecated 주석 달린 함수 취소줄 그어짐Reference 코딩애플, 자바스크립트 2...", "content": "JSDoc 주석 및 타입을 적어두고 보여주는 기능을 함. 해당 주석이 달린 함수를 사용하는 부분에 IDE에서 마우스를 올리면 써 두었던 주석이 출력됨/**내용*/ @~~~로 속성을 알려줄 수 있음 @type {string} 타입 @todo 할 일 @deprecated 주석 달린 함수 취소줄 그어짐Reference 코딩애플, 자바스크립트 20년차 개발자처럼 주석다는 법, 2022.10.10" }, { "title": "[JavaScript] Array 역순으로 출력하기 (Array.reverse)", "url": "/posts/TIL-array-221007/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-10-07 00:00:00 +0900", "snippet": "Array.reverse 테이블 내용을 역순으로 출력하기 위해 검색 array 배열 .reverse() 를 사용해서 역순 출력```const array = [1, 2, 3];const reverse = array.reverse();console.log(reverse, ‘reverse’);// output : [3, 2, 1], ‘reverse’``...", "content": "Array.reverse 테이블 내용을 역순으로 출력하기 위해 검색 array 배열 .reverse() 를 사용해서 역순 출력```const array = [1, 2, 3];const reverse = array.reverse();console.log(reverse, ‘reverse’);// output : [3, 2, 1], ‘reverse’```Reference mdn web docs, Array.prototype.reverse(), 2022.10.8" }, { "title": "ROI(Return On Investment), git flow가 안 좋다는 글을 읽고...", "url": "/posts/TIL-ROI-220729/", "categories": "TIL, 용어, Git", "tags": "", "date": "2022-07-29 00:00:00 +0900", "snippet": "ROI(Return On Investment) 투자 이익률을 이야기 한다. IT업계보다는 투자 관련해서 많이 쓰는 용어 투자한 것에 비해 얼마나 이익이 올랐는지를 나타내는 지표 FE Unit Test는 투자 대비 경제성이 안 좋을 가능성이 클 것 같다는 고민 중에 다른 분에게 들은 용어git flow가 안 좋다는 글을 읽고 생각 정리 git ...", "content": "ROI(Return On Investment) 투자 이익률을 이야기 한다. IT업계보다는 투자 관련해서 많이 쓰는 용어 투자한 것에 비해 얼마나 이익이 올랐는지를 나타내는 지표 FE Unit Test는 투자 대비 경제성이 안 좋을 가능성이 클 것 같다는 고민 중에 다른 분에게 들은 용어git flow가 안 좋다는 글을 읽고 생각 정리 git flow에 대해서 부정적인 입장의 포스트를 보면서 ROI에 대한 이야기까지 나오게 되었다. 커리어리에서 어떤 개발자 분의 글을 보다가 고민에 빠졌다. git flow를 활용해서 develop 브랜치를 두는 것이 효율적이지 않다는 내용이었다. 현재 서비스를 개발하는 회사들이 애자일을 중시하며 빠른 간격의 출시를 하는 경우가 많고 따라서 develop 브랜치에 통합하고 다시 배포해야 하는 과정이 쓸데 없이 번거롭다는 것이었다. 이 의견에 동의가 되지 않아 다른 프론트엔드 개발자분과 이야기를 나눴는데, 글 쓰신 분이 아마 백엔드 개발자가 아닐까 한다는 이야기를 들었다. 백엔드 개발에서는 Unit Test를 거의 완벽하게 할 수 있기 때문에 배포 후 버그가 생길 가능성이 프론트엔드 개발보다는 줄어든다. 프론트엔드 개발에서 모든 부분에 대해서 Unit Test를 수행하는 것은 사실상 어렵다. 왜냐하면 페이지마다 모양이 다르고, 버튼을 눌렀을 때 나오는 결과도 매번 다르기 때문에 한 컴포넌트에 대한 Unit Test를 만들었다고 해도 다른 컴포넌트에서 동일하게 사용하기는 쉽지 않기 때문이다. (이 부분에 대해서는 긴 포스트가 따로 필요할 것 같다.) 따라서 백엔드 개발을 하는 입장에서는 develop 브랜치가 쓸데 없이 작업을 두 번하게 만든다고 느낄 수 있다. 하지만 프론트엔드 개발에서는 아무리 조심한다고 해도, 배포 버전에서 예상치 못한 오류가 발생할 가능성이 크다. 좋은 케이스는 아니지만 많은 회사에서 프론트엔드 개발에 Unit Test를 포기하고 있다고 한다. 그 이유가 ROI가 낮기 때문이다. (회사는 돈이 가장 중요하기 때문에…) 따라서 develop 브랜치를 두고 해당 브랜치로 배포하는 develop 서버가 있는 것이 좋다고 생각한다. 번거롭기는 하지만 정식 배포 전 develop 서버나 stage 서버를 하나 더 만들어서 QA를 진행하고 올리는 것이 안정적이라고 생각하고, git flow는 그런 관점에서 효율적인 브랜치 관리 방법이라고 생각한다.Reference sales force, ROI란? ROAS와의 차이와 개요를 알고 마케팅 효율화를 높이자, 2021.06.03" }, { "title": "[JavaScript] array.splice(), RTK Query 자동 리패칭", "url": "/posts/TIL-array-splice-220728/", "categories": "TIL, JavaScript, RTK_Query", "tags": "", "date": "2022-07-28 00:00:00 +0900", "snippet": "Array.prototype.splice() array.splice(*start*[, *deleteCount*[, *item1*[, *item2*[, *...*]]]]) 위 처럼 사용 deleteCount를 입력하지 않거나 전체 배열의 길이보다 더 크면 배열 안의 모든 데이터 삭제const months = ['Jan', 'March', 'Apri...", "content": "Array.prototype.splice() array.splice(*start*[, *deleteCount*[, *item1*[, *item2*[, *...*]]]]) 위 처럼 사용 deleteCount를 입력하지 않거나 전체 배열의 길이보다 더 크면 배열 안의 모든 데이터 삭제const months = ['Jan', 'March', 'April', 'June'];months.splice(1, 0, 'Feb');// inserts at index 1console.log(months);// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"June\"]months.splice(4, 1, 'May');// replaces 1 element at index 4console.log(months);// expected output: Array [\"Jan\", \"Feb\", \"March\", \"April\", \"May\"]RTK Query 자동 리패칭들어가기 RTK Query를 사용하면서 새로운 데이터를 추가 했을 때 캐시되어 있는 테이블의 데이터를 업데이트 시키고 싶었다. 이런 기능을 RTK Query에서 아주 간단하게 사용할 수 있도록 제공하고 있었다.방법import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query'import type { Post } from './types'const api = createApi({ baseQuery: fetchBaseQuery({ baseUrl: '/', }), tagTypes: ['Post', 'User'], endpoints: (build) =&gt; ({ getPosts: build.query&lt;Post[], void&gt;({ query: () =&gt; '/posts', providesTags: ['Post'], }), addPost: build.mutation&lt;Post, Omit&lt;Post, 'id'&gt;&gt;({ query: (body) =&gt; ({ url: 'post', method: 'POST', body, }), invalidatesTags: ['Post'], }), }),}) 위 코드를 보면 createApi 부분에서 tagType이라는 메서드로 태그를 관리할 수있다. Query에는 providesTags를 추가해서 해당 태그에 연결 시킨다. (구독!) Mutation에는 invalidatesTags에 해당 태그를 연결 시킨다. (역시 구독!) Query는 데이터를 읽어올 때 (api의 get에 주로 사용) Mutation은 데이터를 업데이트, 추가할 때 (api의 post나 fetch에 주로 사용) 사용한다. 이렇게 연결했을 때 Mutation이 성공하면 자동으로 Query는 다시 리패칭을 실행하여 새로운 값을 받아온다. 기존에 받았던 값을 캐시하여 API 요청 부담을 줄여주고, 필요할 때 API에 요청하여 새로운 값을 받아올 수 있는 것이다.Reference mdn web docs, Array.prototype.splice(), 2020.12.09 Redux Toolkit, Using RTK Query - Automated Re-ferching, 2022.06.24" }, { "title": "[RTK Query] Mutation과 캐싱(Caching)", "url": "/posts/TIL-rtk_query-caching/", "categories": "TIL, RTK_Query", "tags": "", "date": "2022-07-26 00:00:00 +0900", "snippet": "Mutations 서버에서 데이터 업데이트, 추가를 요청하고 변경사항을 캐시에 적용할 때 사용한다. 캐시된 데이터를 무효화하고 강제로 다시 가져올 수도 있다.(리패칭) createApi의 endpoints에 아래와 같이 추가해서 세팅. updatePost: build.mutation&lt;responseType, requestType&...", "content": "Mutations 서버에서 데이터 업데이트, 추가를 요청하고 변경사항을 캐시에 적용할 때 사용한다. 캐시된 데이터를 무효화하고 강제로 다시 가져올 수도 있다.(리패칭) createApi의 endpoints에 아래와 같이 추가해서 세팅. updatePost: build.mutation&lt;responseType, requestType&gt;({ query: (body) =&gt; ({ url: `post/add`, method: 'POST', body, }), 요청한 데이터의 반환 값을 캐싱하려면 createApi에 태그 타입을 정의 tagTypes: ['Posts'], 그리고 Mutation 안에 invalidatesTags 추가 updatePost: build.mutation&lt;responseType, requestType&gt;({ query: (body) =&gt; ({ url: `post/add`, method: 'POST', body, }), invalidatesTags: () =&gt; [{ type: 'Posts'}], invalidatesTags안의 콜백 함수를 통해 특정 값만 캐싱하는 것도 가능Reference Redux Toolkit, Using RTK Query - Mutations, 2022.06.24" }, { "title": "[TypeScript] React SetState Prop으로 넘길 때 Type 정의하기", "url": "/posts/TIL-react-setState-type-220715/", "categories": "TIL, React, TypeScript", "tags": "", "date": "2022-07-15 00:00:00 +0900", "snippet": "들어가기 처음으로 React에서 TypeScript를 사용할 때 많이 당황했었다. 그 이유는 부모 컴포넌트에서 자식 컴포넌트로 prop을 넘겨주는 일 때문이었다. JavaScript에서는 함수, 변수 상관없이 그냥 넘겨주면 됐었다. 하지만 TypeScript는 모든 타입을 다 넘겨 주어야 했다. 그 중에서 가장 난감했던 것이 useState ...", "content": "들어가기 처음으로 React에서 TypeScript를 사용할 때 많이 당황했었다. 그 이유는 부모 컴포넌트에서 자식 컴포넌트로 prop을 넘겨주는 일 때문이었다. JavaScript에서는 함수, 변수 상관없이 그냥 넘겨주면 됐었다. 하지만 TypeScript는 모든 타입을 다 넘겨 주어야 했다. 그 중에서 가장 난감했던 것이 useState 훅을 사용했을 때 setState를 넘기는 일이었다. setState를 prop으로 넘기는 방법을 알지 못해서 아래와 같이 함수를 만들어서 자식 컴포넌트로 넘겼다. const changeState = (changeValue: string): void =&gt; { setStateValue(changeValue); } 위와 같은 함수를 부모 컴포넌트에 만들고 자식 컴포넌트로 해당 함수를 넘기는 방법이다. 하지만.. 간단하게 setState를 넘기고 타입을 정의할 수 있다.setState의 타입 정의 useState 훅을 아래와 같이 사용했다고 한다면 const [stateValue, setStateValue] = useState&lt;string&gt;(); 자식 컴포넌트로 넘길 때는 아래와 같이 타입을 정해주면 된다.setStateValue: React.Dispatch&lt;React.SetStateAction&lt;string&gt;&gt;; 전체적으로 다시 보면//부모 컴포넌트import React, {useState} from 'react';import ChildrenComponent from './.';const parentComponent = () =&gt; { const [stateValue, setStateValue] = useState&lt;string&gt;(); return ( &lt;ChildrenComponent setStateValue={setStateValue} /&gt; )}//자식 컴포넌트import React from 'react';interface Props { setStateValue: React.Dispatch&lt;React.SetStateAction&lt;string&gt;&gt;;}const ChildrenComponent = (props: Props) =&gt; { const chagneState = (e) =&gt; { setStateValue(e.target.value); } return ( &lt;div&gt; &lt;button onClick={changeState}&gt;click&lt;/button&gt; &lt;/div&gt; )}Reference Sweet But Psycho, setState로 prop을 넘길 때, 2021.12.23" }, { "title": "로띠(Lotte) - 코드로 삽입하는 애니메이션", "url": "/posts/TIL-lottie-220712/", "categories": "TIL, Lottie", "tags": "", "date": "2022-07-12 00:00:00 +0900", "snippet": "들어가기 동아리 활동 중 로띠를 활용하면 애니메이션이 즐거울 것 같다는 이야기를 들었다. 로띠가 뭔지 바로 검색 찾아보니 구글홈을 설정할 때 봤던 애니메이션이 로띠였다.로띠 (Lottie)는? 위키백과에서는 백터 애니메이션을 위한 파일 형식이라고 소개하고 있다. 로띠에서는 JSON 파일을 사용한다. 따라서 파일 내부를 열어 보면 SVG처럼 ...", "content": "들어가기 동아리 활동 중 로띠를 활용하면 애니메이션이 즐거울 것 같다는 이야기를 들었다. 로띠가 뭔지 바로 검색 찾아보니 구글홈을 설정할 때 봤던 애니메이션이 로띠였다.로띠 (Lottie)는? 위키백과에서는 백터 애니메이션을 위한 파일 형식이라고 소개하고 있다. 로띠에서는 JSON 파일을 사용한다. 따라서 파일 내부를 열어 보면 SVG처럼 뭔가 읽을 수 있는 코드를 볼 수 있다. 로띠 라이브러리를 사용해서 JSON파일을 애니메이션으로 출력할 수 있다.장점 용량이 작다. 공식 홈페이지에서 소개하는 예시에 따르면 gif파일보다 600%더 작다고 한다. 위에 삽입한 애니메이션의 경우 Lottie는 56KB GIF 파일은 375KB이다. 크기가 커져도 깨지지 않는다. 백터 기반이기 때문에 크기가 커진다고 해도 자연스럽다. 그래서 크기가 큰 이미지의 경우 Lottie가 훨씬 용량이 작을 것이다. 단점 컴퓨터 자원을 활용한다. 단순하게 이미지를 순서대로 보여주는 것이 아니다. (GIF 애니메이션) 따라서 컴퓨터가 애니메이션을 표현하기 위해 계산이 들어가야 한다. (하지만, 이미지 여러장을 처리하는 것보다 애니메이션을 계산하여 처리하는게 더 빠를지도…) Reference LottieFiles, Landing Page, 2022.07.12 Access Wikipedia, Lottie (file format), 2022.07.12 Access" }, { "title": "Node 버전 관리하기 (NVM)", "url": "/posts/TIL-NVM-220711/", "categories": "TIL, Node.js", "tags": "", "date": "2022-07-11 00:00:00 +0900", "snippet": "NVM(Node Version Manager) Node를 이전 버전으로 돌리거나 올리는 것을 쉽게 하게 도와주는 역할을 함.설치 Brew가 설치되어 있다면 brew install nvm환경변수 설정 터미널에서 .nvm 디렉토리 만들기 mkdir ~/.nvm vi 편집기로 편집 vi ~/.bash_pro...", "content": "NVM(Node Version Manager) Node를 이전 버전으로 돌리거나 올리는 것을 쉽게 하게 도와주는 역할을 함.설치 Brew가 설치되어 있다면 brew install nvm환경변수 설정 터미널에서 .nvm 디렉토리 만들기 mkdir ~/.nvm vi 편집기로 편집 vi ~/.bash_profile 맨 밑으로 내려와서 아래 내용 입력export NVM_DIR=\"$HOME/.nvm\"[ -s \"/opt/homebrew/opt/nvm/nvm.sh\" ] &amp;&amp; \\. \"/opt/homebrew/opt/nvm/nvm.sh\" #[ -s \"/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm\" ] &amp;&amp; \\. \"/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm\" # This loads nvm bash_completion (o나 i를 눌러서 입력모드로 전환 후 다 입력했으면 esc를 누르고 :wq 를 입력하고 엔터치면 저장 종료됨. source ~/.bash_profile 을 터미널에 입력해서 환경변수 적용 다 설치가 되었다면 nvm -v를 눌러서 확인 버전 설치는 nvm install 14 처럼 원하는 버전을 입력해서 설치 버전 바꾸는 것은 nvm use 14 처럼 원하는 버전을 입력해서 변경Reference https://somjang.tistory.com/entry/macOS에-nvm설치하는-방법-feat-brew" }, { "title": "Windows에서 리눅스 - WSL, 도메인 주도 설계 - DDD", "url": "/posts/TIL-WSL_ddd-220706/", "categories": "TIL, CS", "tags": "", "date": "2022-07-06 00:00:00 +0900", "snippet": "WSL (Windows Subsystem for Linux) 윈도우 10, 11에서 네이티브로 리눅스 실행 파일을 작동시키기 위해서 사용. WSL에 도커, code-server를 이용해서 개발하는 경우도 있음. 가상머신을 사용해서 리눅스를 돌리면 무겁다는 단점이 있음. 하지만 WSL을 이용하면 리눅스 프로그램을 가볍게 이용할 수 있음. WSL...", "content": "WSL (Windows Subsystem for Linux) 윈도우 10, 11에서 네이티브로 리눅스 실행 파일을 작동시키기 위해서 사용. WSL에 도커, code-server를 이용해서 개발하는 경우도 있음. 가상머신을 사용해서 리눅스를 돌리면 무겁다는 단점이 있음. 하지만 WSL을 이용하면 리눅스 프로그램을 가볍게 이용할 수 있음. WSL을 이용하면 ZSH등의 터미널을 사용하기 편리하다 (Powershall과 다름)DDD (Domain Driven Design) 도메인 주도 설계 도메인과 도메인 로직에 초점을 맞춤. 도메인 별로 분리 높은 응집력, 낮은 결합도 설계 여기서 확장한 것이 마이크로서비스Reference http://youngrok.com/%EC%9C%88%EB%8F%84%EC%9A%B0%20%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%20%EC%82%BD%EC%A7%88%EA%B8%B0 https://huisam.tistory.com/entry/DDD https://incheol-jung.gitbook.io/docs/q-and-a/architecture/ddd" }, { "title": "[JavaScript] 소문자로 변환 - String.prototype.toLowerCase()", "url": "/posts/TIL-toLowerCase-220705/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-07-05 00:00:00 +0900", "snippet": "toLowerCase() 문자열의 대문자를 소문자로 변환 검색 처리 시 검색 값과 데이터 모두 toLowerCase를 적용시키고 필터링하면 이용자가 더 많은 검색결과를 얻을 수 있음const sentence = 'The quick brown fox jumps over the lazy dog.';console.log(sentence.toLowerCa...", "content": "toLowerCase() 문자열의 대문자를 소문자로 변환 검색 처리 시 검색 값과 데이터 모두 toLowerCase를 적용시키고 필터링하면 이용자가 더 많은 검색결과를 얻을 수 있음const sentence = 'The quick brown fox jumps over the lazy dog.';console.log(sentence.toLowerCase());// expected output: \"the quick brown fox jumps over the lazy dog.\"Reference https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/toLowerCase" }, { "title": "Object.keys() - 객체 key를 배열로", "url": "/posts/TIL-abusing-220704/", "categories": "TIL, CS, JavaScript", "tags": "", "date": "2022-07-04 00:00:00 +0900", "snippet": "Object.keys() 객체의 key를 배열로 반환const object = {a: 1, b: 2, c: 3}console.log(Object.key(object));// 결과: [\"a\", \"b\", \"c\"]Reference https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global...", "content": "Object.keys() 객체의 key를 배열로 반환const object = {a: 1, b: 2, c: 3}console.log(Object.key(object));// 결과: [\"a\", \"b\", \"c\"]Reference https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" }, { "title": "다이나믹 서브셋", "url": "/posts/TIL-dynamic_subset-220627/", "categories": "TIL, CSS", "tags": "", "date": "2022-06-27 00:00:00 +0900", "snippet": "배운 것다이나믹 서브셋 서브셋 폰트 일반적으로 사용하는 문자만 남겨 용량을 줄인 폰트 다이나믹 서브셋 CSS의 unicode-range 속성을 이용해서 해당 문자가 사용될 때 브라우저가 폰트 파일을 다운로드 하는 방식 자세한 사용방식은 링크의 블로그 참조 Reference https:/...", "content": "배운 것다이나믹 서브셋 서브셋 폰트 일반적으로 사용하는 문자만 남겨 용량을 줄인 폰트 다이나믹 서브셋 CSS의 unicode-range 속성을 이용해서 해당 문자가 사용될 때 브라우저가 폰트 파일을 다운로드 하는 방식 자세한 사용방식은 링크의 블로그 참조 Reference https://velog.io/@twain/Google-Fonts%EC%B2%98%EB%9F%BC-%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9-%EC%84%9C%EB%B8%8C%EC%85%8B-%ED%8F%B0%ED%8A%B8-%EB%A7%8C%EB%93%A4%EC%96%B4-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0" }, { "title": "preflight", "url": "/posts/TIL-preflighted-220620/", "categories": "TIL, http", "tags": "", "date": "2022-06-20 00:00:00 +0900", "snippet": "배운 것Preflight Request 본 요청 전에 사전 요청을 하는 것. 일반적인 경우에서는 Preflight를 먼저 요청하지 않음. GET, HEAD, POST이외의 경우 preflight Request Content-Type 헤더에 허용된 값 이외에 작성된 경우 등…Reference https://jsikim1.tistory.com/1...", "content": "배운 것Preflight Request 본 요청 전에 사전 요청을 하는 것. 일반적인 경우에서는 Preflight를 먼저 요청하지 않음. GET, HEAD, POST이외의 경우 preflight Request Content-Type 헤더에 허용된 값 이외에 작성된 경우 등…Reference https://jsikim1.tistory.com/184 https://www.popit.kr/cors-preflight-%EC%9D%B8%EC%A6%9D-%EC%B2%98%EB%A6%AC-%EA%B4%80%EB%A0%A8-%EC%82%BD%EC%A7%88/" }, { "title": "어뷰징, 리프레시 토큰, Redis", "url": "/posts/TIL-refresh_token_redis-220614/", "categories": "TIL, http", "tags": "", "date": "2022-06-14 00:00:00 +0900", "snippet": "배운 것 어뷰징(Abusing) 부정 행위를 통해 이득을 취하는 행동 예를 들면 사이트에서 보안에 취약한 부분을 악용하여 이득을 취함 리프레시 토큰 (Refresh Token) 엑세스 토큰의 유효 시간이 지났을 때 다시 새로운 엑세스 토큰을 발급 받는 방법 Elasticsearch ...", "content": "배운 것 어뷰징(Abusing) 부정 행위를 통해 이득을 취하는 행동 예를 들면 사이트에서 보안에 취약한 부분을 악용하여 이득을 취함 리프레시 토큰 (Refresh Token) 엑세스 토큰의 유효 시간이 지났을 때 다시 새로운 엑세스 토큰을 발급 받는 방법 Elasticsearch 공식 분산형 검색 및 분석 엔진 Redis key와 value 구조의 비정형 데이터를 저장하고 관리하기 위한 비관계형 데이터베이스 관리 시스템 Reference https://opentutorials.org/course/3405/22010 https://namu.wiki/w/%EC%96%B4%EB%B7%B0%EC%A7%95 https://ko.wikipedia.org/wiki/%EB%A0%88%EB%94%94%EC%8A%A4 https://www.elastic.co/kr/elasticsearch/" }, { "title": "Next Auth로 소셜 로그인 구현", "url": "/posts/TIL-nextauth-220613/", "categories": "TIL, Nextjs", "tags": "", "date": "2022-06-13 00:00:00 +0900", "snippet": "배운 것Next Auth좋은 점 Nextjs 간편하게 소셜 로그인을 구현할 수 있음. Server, Client 모두 Nextjs 하나로 구현할 수 있음.궁금증 provider의 인증 토큰을 따로 받을 수 있는 지 모르겠음. Java서버 백단에서 토큰 유효성 인증을 해줄 수 있는 방법이 있을까?설치 (v4 기준)$yarn add next-aut...", "content": "배운 것Next Auth좋은 점 Nextjs 간편하게 소셜 로그인을 구현할 수 있음. Server, Client 모두 Nextjs 하나로 구현할 수 있음.궁금증 provider의 인증 토큰을 따로 받을 수 있는 지 모르겠음. Java서버 백단에서 토큰 유효성 인증을 해줄 수 있는 방법이 있을까?설치 (v4 기준)$yarn add next-auth사용 방법 pages/api/[...nextauth].ts 파일을 생성import NextAuth from \"next-auth\"import GithubProvider from \"next-auth/providers/github\"export default NextAuth({ providers: [ GithubProvider({ clientId: process.env.GITHUB_ID, clientSecret: process.env.GITHUB_SECRET, }), ],}) 원하는 공급자(provider)를 위 providers 배열에 추가해 주면 됨. 공급자 목록은 -&gt; https://next-auth.js.org/providers/ 예를 들어 Apple로그인을 추가하고 싶다면 아래와 같이 추가import NextAuth from \"next-auth\"import GithubProvider from \"next-auth/providers/github\"import AppleProvider from \"next-auth/providers/apple\";export default NextAuth({ providers: [ GithubProvider({ clientId: process.env.GITHUB_ID, clientSecret: process.env.GITHUB_SECRET, }), AppleProvider({ clientId: process.env.APPLE_ID, clientSecret: process.env.APPLE_SECRET }), ],}) 그 다음 _app.tsx 컴포넌트 SessionProvider로 감싸기import { SessionProvider } from \"next-auth/react\"export default function App({ Component, pageProps: { session, ...pageProps },}) { return ( &lt;SessionProvider session={session}&gt; &lt;Component {...pageProps} /&gt; &lt;/SessionProvider&gt; )} Hook을 사용해서 로그인, 로그아웃, 세션 확인 가능import { useSession, signIn, signOut } from \"next-auth/react\"export default function Component() { const { data: session } = useSession() if (session) { return ( &lt;&gt; Signed in as {session.user.email} &lt;br /&gt; &lt;button onClick={() =&gt; signOut()}&gt;Sign out&lt;/button&gt; &lt;/&gt; ) } return ( &lt;&gt; Not signed in &lt;br /&gt; &lt;button onClick={() =&gt; signIn()}&gt;Sign in&lt;/button&gt; &lt;/&gt; )}Reference https://next-auth.js.org/getting-started/example" }, { "title": "React Helmet", "url": "/posts/TIL-react-helmet-220612/", "categories": "TIL, React, Library", "tags": "MetaTag", "date": "2022-06-12 00:00:00 +0900", "snippet": "배운 것React-Helmet 라이브러리사용하는 곳 React에서 헤더 태그에 무엇을 넣어야할 때 사용한다. 내가 필요했던 곳은 메타 태그를 넣기 위해서였다. 메타 태그의 Theme-color를 넣기 위해 사용했다.설치 react-helmet을 설치했는데 자꾸 에러가 나서 react-helmet-async을 설치했다$yarn add react...", "content": "배운 것React-Helmet 라이브러리사용하는 곳 React에서 헤더 태그에 무엇을 넣어야할 때 사용한다. 내가 필요했던 곳은 메타 태그를 넣기 위해서였다. 메타 태그의 Theme-color를 넣기 위해 사용했다.설치 react-helmet을 설치했는데 자꾸 에러가 나서 react-helmet-async을 설치했다$yarn add react-helmet-async사용 방법 index.tsx에서 &lt;App /&gt;을 &lt;HelmetProvider&gt;로 감싼다&lt;HelemetProvider&gt; &lt;App /&gt;&lt;/HelemetProvider&gt; 필요한 곳에서 &lt;Helmet&gt; &lt;/Helmet&gt;으로 감싸고 Header에 넣을 내용을 포함시키면 된다.Reference https://velog.io/@miyoni/noSSRyesSEO https://jeonghwan-kim.github.io/dev/2020/08/15/react-helmet.html https://www.npmjs.com/package/@types/react-helmet" }, { "title": "Geolocation API - 위치 정보 받아오기", "url": "/posts/TIL-location-220611/", "categories": "TIL, JavaScript", "tags": "Geolocation", "date": "2022-06-11 00:00:00 +0900", "snippet": "배운 것Geolocation API기능 브라우저에서 위도와 경도 값을 받아오는 기능을 함.geolocation 객체 navigator.geolocation 객체를 통해 Geolocation API를 사용할 수 있음.사용 방법 geolocation 객체가 존재하는 지 확인if('geolocation' in navigator) { /* 위치정보 사...", "content": "배운 것Geolocation API기능 브라우저에서 위도와 경도 값을 받아오는 기능을 함.geolocation 객체 navigator.geolocation 객체를 통해 Geolocation API를 사용할 수 있음.사용 방법 geolocation 객체가 존재하는 지 확인if('geolocation' in navigator) { /* 위치정보 사용 가능 */} else { /* 위치정보 사용 불가능 */} 현재 위치 가져오기 getCurrentPosition() 메서드를 호출해서 현재 위치를 받아올 수 있다. navigator.geolocation.getCurrentPosition((position) =&gt; {doSomething(position.coords.latitude, position.coords.longitude); }); 참고로 첫 번째 매개변수로 넣은 콜백함수에서 위치를 받아오는데 두 번째 매개변수에 콜백함수를 넣으면 값을 받아오는 것이 실패했을 때 실행될 코드를 작성할 수 있다. navigator.geolocation.getCurrentPosition((position) =&gt; {doSomething(position.coords.latitude, position.coords.longitude); }, () =&gt; { console.log('실패했어 ㅠㅠ') }); 현재 위치 추적하기 watchPosition() 메서드로 바뀐 위치 정보를 호출할 수 있다. const watchID = navigator.geolocation.watchPosition((position) =&gt; {doSomething(position.coords.latitude, position.coords.longitude);}); Reference mdn Geolocaiton API 사용하기" }, { "title": "[고민] 타입스크립트에서 타입이 정확한 경우 지정하지 않는 것이 맞는가?", "url": "/posts/TIL-type-inference-220603/", "categories": "TIL, TypeScript", "tags": "", "date": "2022-06-03 00:00:00 +0900", "snippet": "들어가기 타입스크립트로 프로젝트를 진행하는 중 의문이 생겼다.const LOGIN_ID = 'login id';const array = ['abc', 'bbc', 'ccc']; 위와 같은 코드의 경우 LOGIN_ID는 한 눈에 타입 판단이 가능하고 TypeScript도 자동 타입 추론(Type Inference)으로 string이라고 판단할 것이다...", "content": "들어가기 타입스크립트로 프로젝트를 진행하는 중 의문이 생겼다.const LOGIN_ID = 'login id';const array = ['abc', 'bbc', 'ccc']; 위와 같은 코드의 경우 LOGIN_ID는 한 눈에 타입 판단이 가능하고 TypeScript도 자동 타입 추론(Type Inference)으로 string이라고 판단할 것이다. 과연 이 경우에도 타입을 지정해야 하는가?라는 의문이 들었다.모든 타입을 선언했을 때 장점과 단점 간단한 코드라도 타입을 선언했을 때 장점 코드를 읽으면서 정확한 타입을 볼 수 있다. 예를 들면 let StudentCount = '1'; 위와 같은 코드에서 보통이라면 number타입을 지정해서 사용하겠지만 특정 API가 string으로만 값을 받는다고 하여 타입을 string으로 지정해주었다. 이 경우 스쳐 지나가다가 잘못보아 number로 착각할 수 있다. 타입 추론에 의해서 number로 썼을 때 오류는 발생할 수도 있다. 하지만 let StudentCount: string = '1'; 이라고 쓰는 게 조금 더 명확하다. 우리의 예상보다 더 정확한 타입으로 추론되는 것을 막을 수 있다. const 1: string = 'x'; // 타입은 stringconst 2 = 'y'; // 타입은 'y' 단점 타입이 정확한데 추가적으로 타입을 전부 작성해야 하니 코드가 길어진다. const x: number = 15;const x = 15; 따라서… 정말로 변할 일이 없는 정확한 경우에 타입을 선언하지 않고, 그렇지 않은 경우에는 기본적으로 모두 타입을 선언하는 것이 좋을 것 같다.하지만 궁금한 점… React에서 타입스크립트를 사용할 때 tsx 컴포넌트의 타입 선언을 해야 하는 지 의문이다.```//Counter.tsximport {React, ReactElement} from ‘react’;const Counter = ():ReactElement =&gt; {return ( &lt;div&gt; Counter &lt;/div&gt;)};export default Counter;- 위와 같은 파일이 있다고 할 때- 파일 확장자는 `tsx` 즉, 파일을 열 때부터 이 파일에는 `tsx`가 들어간다는 것을 알고 있고 안에 들어가는 함수는 당연히 `ReactElement`를 리턴한다는 것을 알고 있을 것인데- 굳이 `():ReactElement`를 선언해 주어야 할까?- 개인적인 생각으로는 해당 파일 안에 함수가 여러개가 존재한다면 `ReactElement`를 리턴한다고 타입을 지정해 주어야 하고,- 아니라면 쓰지 않아도 될 것 같다는 생각이다.//Counters.tsximport {React, ReactElement} from ‘react’;export const AddCounterValue = (value: number, plus: nubmer): number =&gt; (value + plus);const Counter = ():ReactElement =&gt; {return ( &lt;div&gt; Counter &lt;/div&gt;)};export default Counter;``` 위처럼 한 파일 안에 두 가지 함수가 있다고 하면 함수의 성격을 구분하기 위해서 리턴 값의 타입을 지정해줘도 될 것 같다는 생각은 있다. (하지만 위 처럼 코드를 작성하는 경우는 없을 것 같다.)그 외 복습 위의 고민들은 타입이 확실할 때의 타입 선언에 관한 고민이고, 확실하지 않은 경우는 무조건 선언해야 한다. 이전 글(TypeScript Narrowing, TIL, 220226)Reference 오웬의 개발 이야기, [이펙티브 타입스크립트] 3장 타입 추론, 2022.03.07, https://devowen.com/440#%EC%–%–%EC%-D%B-%ED%–%-C%—–%–%EC%B-%–%EB%A-%A-%–%EA%B-%–%EB%-A%A-%ED%–%-C%–%ED%–%–%EC%-E%–%EC%-D%–%–%EC%–%AC%EC%-A%A-%ED%–%B-%–%EC%-E%A-%ED%–%A-%ED%–%-C%–%EC%BD%–%EB%–%-C%–%EB%B-%A-%EC%A-%–%ED%–%–%EA%B-%B-" }, { "title": "[Node.js]Event emitter", "url": "/posts/TIL-EventEmitter-220602/", "categories": "TIL, Node.js", "tags": "", "date": "2022-06-02 00:00:00 +0900", "snippet": "Event emitter 어떤 동작이 실행되었을 때 이벤트를 인식하고 이벤트를 인식했을 때 다른 행위를 실행시키는 것 이벤트 리스너라고 생각하면 쉽다.자세하게 다시 정리 JavaScript를 브라우저에서 사용할 때 DOM 이벤트를 받는 이벤트 리스너의 사용 방법은 다음과 같다.const button = document.querySelector(\"...", "content": "Event emitter 어떤 동작이 실행되었을 때 이벤트를 인식하고 이벤트를 인식했을 때 다른 행위를 실행시키는 것 이벤트 리스너라고 생각하면 쉽다.자세하게 다시 정리 JavaScript를 브라우저에서 사용할 때 DOM 이벤트를 받는 이벤트 리스너의 사용 방법은 다음과 같다.const button = document.querySelector(\"button\");button.addEventListener(\"click\", (event) =&gt; { console.log(`clicked`);}) 그런데 DOM 이벤트가 아니고 다른 행위(트리거)를 기반으로 이벤트를 내보내고 응답하도록 할 때 custom event emitter가 필요하다.let n = 0;const event = new EventEmitter();event.subscribe(\"THUNDER_ON_THE_MOUNTAIN\", value =&gt; (n = value));event.emit(\"THUNDER_ON_THE_MOUNTAIN\", 18);// n: 18event.emit(\"THUNDER_ON_THE_MOUNTAIN\", 5);// n: 5 위 예제에서 THUNDER_ON_THE_MOUNTAIN이라는 이름의 이벤트를 구독한다. (subscribe) 이벤트가 발생할 때마다 value =&gt; (n=value) 콜백함수가 실행된다. 이벤트를 발생시키기 위해 emit 을 사용했다. evetn.emit('THUNDER_ON_THE_MOUNTAIN', 18)은 THUNDER_ON_THE_MOUNTAIN이벤트의 값(value)를 18로 설정했기 때문에 변수 let n의 값도 18로 변경되었다. 예시는 다음 글을 참고했습니다. (https://css-tricks.com/understanding-event-emitters/)Reference Node.js, The Node.js Event emitter : https://nodejs.dev/learn/the-nodejs-event-emitter CSS-TRICKS, Understanding Event Emitters, 2019.03.25" }, { "title": "[React 18] useTransition", "url": "/posts/TIL-useTransition-220527/", "categories": "TIL, React", "tags": "", "date": "2022-05-27 00:00:00 +0900", "snippet": "컨커런트 UI 패턴 화면에 나타나는 변화를 지연시키고 싶은 경우 사용 예를 들면 검색 창에서 실시간으로 검색 결과를 표시할 때 검색 결과 로직 처리보다 검색어 입력을 더 우선적으로 보여주게 하는 것. 디바운싱 기법을 사용해서 이전에 구현했었음.useTransitionconst [startTransition, isPending] = useTrans...", "content": "컨커런트 UI 패턴 화면에 나타나는 변화를 지연시키고 싶은 경우 사용 예를 들면 검색 창에서 실시간으로 검색 결과를 표시할 때 검색 결과 로직 처리보다 검색어 입력을 더 우선적으로 보여주게 하는 것. 디바운싱 기법을 사용해서 이전에 구현했었음.useTransitionconst [startTransition, isPending] = useTransition({ timeoutMs: 3000 }); 위 코드처럼 작성한다면 3초를 기다린다는 이야기 (3000ms) startTransition()안에 있는 함수는 변화를 기다렸다가 업데이트. startTransition(() =&gt; { 내용 }) isPending은 불리언으로 transition이 완료되었을 때 true로 바뀜.Reference https://ko.reactjs.org/docs/concurrent-mode-patterns.html https://velog.io/@katanazero86/React-18-%EC%97%90%EC%84%9C-%EB%8B%AC%EB%9D%BC%EC%A7%80%EB%8A%94%EC%A0%90 https://medium.com/naver-place-dev/react-18%EC%9D%84-%EC%A4%80%EB%B9%84%ED%95%98%EC%84%B8%EC%9A%94-8603c36ddb25" }, { "title": "특정 커밋을 돌릴 때 reset을 쓸까? revert를 쓸까?", "url": "/posts/TIL-git-revert-reset-220526/", "categories": "TIL, Git", "tags": "", "date": "2022-05-26 00:00:00 +0900", "snippet": "들어가기 어떤 작업을 하고 10개 정도의 커밋을 더 했는데 그 모든 작업을 취소하고 싶을 때 reset이 더 맞을까? revert가 더 맞을까? 라고 고민을 했는데, 그 부분에 대해서 포스트를 남긴다.결론은 Revert 간단하게 이전 커밋을 취소하는 경우는 reset으로 남길 수도 있지만 이미 진행한 많은 작업들의 기록을 남기면서 취소하기 위해서는...", "content": "들어가기 어떤 작업을 하고 10개 정도의 커밋을 더 했는데 그 모든 작업을 취소하고 싶을 때 reset이 더 맞을까? revert가 더 맞을까? 라고 고민을 했는데, 그 부분에 대해서 포스트를 남긴다.결론은 Revert 간단하게 이전 커밋을 취소하는 경우는 reset으로 남길 수도 있지만 이미 진행한 많은 작업들의 기록을 남기면서 취소하기 위해서는 Revert가 더 어울림. 일부분만 취소하는 경우는 새로 commit을 올리는 게 기록을 남길 수 있는 측면에서 맞는 것 같음." }, { "title": "쿠키와 document.cookie", "url": "/posts/TIL-cookie-220525/", "categories": "TIL, cookie", "tags": "", "date": "2022-05-25 00:00:00 +0900", "snippet": "들어가기 임시 로그인 페이지를 만들면서 로그인 요청을 했는데, key가 쿠키에 저장되지 않고 JWT data로 반환됐다. 이 경우 JWT는 Local Storage에 넣어야 하는 것인가 Session Storage에 넣어야 하는 것인가 Cookie에 넣을 수 있는 것인가? 고민하다가 Cookie에 대한 글을 읽으면서 Cookie에 대해 알아봤다.쿠...", "content": "들어가기 임시 로그인 페이지를 만들면서 로그인 요청을 했는데, key가 쿠키에 저장되지 않고 JWT data로 반환됐다. 이 경우 JWT는 Local Storage에 넣어야 하는 것인가 Session Storage에 넣어야 하는 것인가 Cookie에 넣을 수 있는 것인가? 고민하다가 Cookie에 대한 글을 읽으면서 Cookie에 대해 알아봤다.쿠키 읽기 document.cookie로 쿠키를 읽을 수 있다. document.cookie는 name=value 쌍으로 구성되어 있다. 각 쌍의 구분은 ;로 구분한다.쿠키 쓰기 document.cookie에 직접 값을 슬 수 있는데 데이터 프로퍼티가 아니고 접근자 프로퍼티에 쓸 수 있다. document.cookie = \"user=John\"; -&gt; 이름이 ‘user’인 쿠키의 값만 갱신함 name=value 쌍은 4KB를 넘을 수 없고 공백 등은 인코딩이 필요하다 (공백 = %20)Reference https://ko.javascript.info/cookie" }, { "title": "Github Actions - 자동 배포~!", "url": "/posts/TIL-GithubActions-220524/", "categories": "TIL, CI/CD", "tags": "", "date": "2022-05-24 00:00:00 +0900", "snippet": "들어가기 회사에서 일을 하다보니까 Github Actions을 사용해서 자동 배포를 해주도록 세팅되어 있었다. 지금까지 자동 배포는 ‘netlify’, ‘heroku’ 등의 서비스를 사용했는데 ‘Github Action’은 조금 다르다. 배포 뿐만 아니라 여러가지 workflow를 자동화 시켜주는 도구이기 때문이다.Github Actions은? ...", "content": "들어가기 회사에서 일을 하다보니까 Github Actions을 사용해서 자동 배포를 해주도록 세팅되어 있었다. 지금까지 자동 배포는 ‘netlify’, ‘heroku’ 등의 서비스를 사용했는데 ‘Github Action’은 조금 다르다. 배포 뿐만 아니라 여러가지 workflow를 자동화 시켜주는 도구이기 때문이다.Github Actions은? workflow를 자동화할 수 있는 도구 가격 : Public Repository -&gt; 무료(제한 있음), Private Repository -&gt; 유료(시간당, 용량당) ‘테스트 코드 실행’, ‘배포(CD)’, ‘자동화하고 싶은 스크립트 실행’ 등에서 사용할 수 있다.자동배포! 백엔드는 Jenkins 등을 사용해서 배포를 하는 것 같은데 프론트엔드는 배포한 파일이 실행되면서 변경되고 하는 것은 없기 때문에, 빌드한 파일이 서버에 올라가서 배포가 된다. (그래서 프론트엔드 프로젝트 배포를 정적 사이트 배포라고 하는 것 같다.) 회사에서는 AWS를 사용해서 배포를 하고 있었고, 그 자동화에 Github Actions을 사용하고 있었다.방법 프로젝트 루트에 .github/workflows/deploy.yml이라는 파일을 만들어서 자동 배포할 스크립트 파일을 만든다. aws 핵심 정보는 secrets를 사용해서 숨겨둔다. .env파일처럼 배포할 때 프로젝트의 설정 부분에서 secrets메뉴에서 환경변수를 설정할 수 있다. 배포를 위한 aws id, key, region은 secrets에 담아둔다. 설정한 브랜치에 merge될 때마다 자동으로 스크립트가 실행되며 배포된다.Reference https://weekwith.tistory.com/entry/Nextjs-AWS-S3%EB%A5%BC-%ED%86%B5%ED%95%9C-%EC%A0%95%EC%A0%81-%EC%9B%B9-%EC%82%AC%EC%9D%B4%ED%8A%B8-%EB%B0%B0%ED%8F%AC-%EB%B0%8F-GitHub-Actions%E1%84%85%E1%85%B3%E1%86%AF-%E1%84%90%E1%85%A9%E1%86%BC%E1%84%92%E1%85%A1%E1%86%AB-CICD" }, { "title": "CI/CD - 자동 배포", "url": "/posts/TIL-CICD-220523/", "categories": "TIL, CI/CD", "tags": "", "date": "2022-05-23 00:00:00 +0900", "snippet": "CI (Continuous Integration) 지속적인 통합. 주로 Git이라는 형상관리 툴을 이용하는데 2명 이상의 개발자가 작업하는 코드가 긴 시간 동안 merge되지 않으면 통합되기 어려울 정도로 달라질 수 있다. 따라서 가능한 작은 단위로 주기적으로 통합하여 나가는 것이 중요한데 이것을 CI이라고 한다.CD(Continuous Deli...", "content": "CI (Continuous Integration) 지속적인 통합. 주로 Git이라는 형상관리 툴을 이용하는데 2명 이상의 개발자가 작업하는 코드가 긴 시간 동안 merge되지 않으면 통합되기 어려울 정도로 달라질 수 있다. 따라서 가능한 작은 단위로 주기적으로 통합하여 나가는 것이 중요한데 이것을 CI이라고 한다.CD(Continuous Delivery) 지속적인 제공. 지속적인 배포 (Continuous Deployment) 배포할 준비가 되면 자동으로 배포하는 것. 이것이 지속적 배포이다. CD를 해놓으면 배포에 신경쓰지 않고 지속적으로 개발에 더 집중할 수 있다. 빌드, 테스트, 배포의 과정이 자동화되서 편하다.Reference https://jud00.tistory.com/entry/CICD%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C" }, { "title": "모노레포 - 한 저장소에서 여러 작업들을 패키지로 관리하기", "url": "/posts/TIL-Monorepo-220522/", "categories": "TIL, Project", "tags": "", "date": "2022-05-22 00:00:00 +0900", "snippet": "모노레포란? 한 저장소(Repository)에서 여러 작업들을 패키지로 함께 관리하는 것. (비슷한 개념으로는 ‘멀티레포’가 있음. 하지만 멀티레포는 여러 저장소로 나눠서 프로젝트를 관리하는 것)장점 공통으로 사용하는 라이브러리, 환경 등을 설정하기 좋음. (린트, 테스트 코드 등) 기능의 모듈화를 했을 때 같은 저장소 안에 있기 때문에 재사용...", "content": "모노레포란? 한 저장소(Repository)에서 여러 작업들을 패키지로 함께 관리하는 것. (비슷한 개념으로는 ‘멀티레포’가 있음. 하지만 멀티레포는 여러 저장소로 나눠서 프로젝트를 관리하는 것)장점 공통으로 사용하는 라이브러리, 환경 등을 설정하기 좋음. (린트, 테스트 코드 등) 기능의 모듈화를 했을 때 같은 저장소 안에 있기 때문에 재사용하기가 용이 한 저장소 안에 있기 때문에 다른 작업들도 쉽게 확인할 수 있음.단점 유사한 제품들이 아니라면 오히려 공통된 라이브러리 관리가 불편하게 느껴질 수 있음.모노레포 구축을 위한 도구 Lerna, Yarn Berry 등Reference https://d2.naver.com/helloworld/0923884" }, { "title": "No Install로 Node 사용 - Yarn Berry", "url": "/posts/TIL-yarnberry-220521/", "categories": "TIL, YarnBerry", "tags": "", "date": "2022-05-21 00:00:00 +0900", "snippet": "들어가기 모노레포에 대해서 살펴보면서 인스톨을 하지 않아도 설치 라이브러리들을 관리할 수 있는 방법이 있다고 하여 테스트 저장소를 만들어서 사용해 봄.사용법 프로젝트 세팅 이후 yarn set version berry 라고 치면 됨 node_modules와 package.lock.json은 더 이상 사용하지 않게 됨 따라서 삭제 추가로 .git...", "content": "들어가기 모노레포에 대해서 살펴보면서 인스톨을 하지 않아도 설치 라이브러리들을 관리할 수 있는 방법이 있다고 하여 테스트 저장소를 만들어서 사용해 봄.사용법 프로젝트 세팅 이후 yarn set version berry 라고 치면 됨 node_modules와 package.lock.json은 더 이상 사용하지 않게 됨 따라서 삭제 추가로 .gitignore를 설정하면 더 편함 gitignore 파일 .yarn/*!.yarn/cache!.yarn/patches!.yarn/plugins!.yarn/releases!.yarn/sdks!.yarn/versions 장점 설치하지 않고도 라이브러리가 저장소에 압축되어 저장되기 때문에 괜찮음. No-install로 버로 사용할 수 있음.Reference https://velog.io/@seokunee/Yarn-Berry%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90" }, { "title": "Strapi 설치 및 Heroku 배포", "url": "/posts/TIL-strapi/", "categories": "TIL, Library, JavaScript", "tags": "", "date": "2022-05-20 00:00:00 +0900", "snippet": "들어가기 지난 주에 CTO님께서 Strapi라는 걸로 백엔드 개발 없이 API를 사용할 수 있다고 말씀하셨다. 다른 부분에 대해서 열심히 진행하다가 API를 슬슬 가져다가 붙여야 하는데 난감했다. 일단 백엔드 구현되기 전까지 프론트만으로도 개발을 진행해야 되서 Strapi를 사용하기로 했다.설치에서 실행까지 strapi 공식 블로그에서 설명한 ...", "content": "들어가기 지난 주에 CTO님께서 Strapi라는 걸로 백엔드 개발 없이 API를 사용할 수 있다고 말씀하셨다. 다른 부분에 대해서 열심히 진행하다가 API를 슬슬 가져다가 붙여야 하는데 난감했다. 일단 백엔드 구현되기 전까지 프론트만으로도 개발을 진행해야 되서 Strapi를 사용하기로 했다.설치에서 실행까지 strapi 공식 블로그에서 설명한 방법으로 진행했기 때문에 오른쪽 링크를 참조해서 보면 따라하기 좋을 것이다. -&gt; [링크] 아니다 공식문서를 따라하는 게 더 좋을 것 같다. -&gt; [링크] 설치 $npx create-strapi-app my-project --quickstart 설치가 끝나면 http://localhost:1337/admin 페이지에서 API를 세팅할 수 있다.(기본으로 User는 잡혀 있다.) Setting - Roles - Public에 들어가서 필요한 API에 체크해주면 API 사용 방법이 같이 뜬다.(이 부분 블로그를 검색하는데 UI가 현재버전과 조금 달라서 조금 헤맸다.)Heroku 배포 Heroku CLI을 설치하면 조금 더 가이드에 맞게 쉽게 따라할 수 있다. 맥에서 설치는 아래와 같다. (brew가 깔려 있어야 한다.) brew tap heroku/brew &amp;&amp; brew install heroku 로그인 heroku login 프로젝트 폴더에서 .gitignore 파일에 아래와 같이 추가 package-lock.json Git 준비하기 cd my-projectgit initgit add .git commit -m \"Initial Commit\" Heroku Project 만들기 heroku create Heroku Postgres addon 설치 heroku addons:create heroku-postgresql:hobby-dev Retrieve database credentials heroku config Set Database variables automatically npm install pg-connection-string --save ./config/env/production/database.js 파일 만들기 내용은 아래처럼 const parse = require('pg-connection-string').parse;const config = parse(process.env.DATABASE_URL);module.exports = ({ env }) =&gt; ({connection: { client: 'postgres', connection: { host: config.host, port: config.port, database: config.database, user: config.user, password: config.password, ssl: { rejectUnauthorized: false }, }, debug: false,},}); env 설정 heroku config:set NODE_ENV=production Strapi server config for production 만들기./config/env/production/server.js파일 만들기아래와 같이 따라 쓰면 됨 module.exports = ({ env }) =&gt; ({proxy: true,url: env('MY_HEROKU_URL'),app: { keys: env.array('APP_KEYS')},}) 콘솔 창에 아래와 같이 따라 쓰기 heroku config:set MY_HEROKU_URL=$(heroku info -s | grep web_url | cut -d= -f2)heroku config:set APP_KEYS=$(cat .env | grep APP_KEYS | cut -d= -f2-)heroku config:set API_TOKEN_SALT=$(cat .env | grep API_TOKEN_SALT | cut -d= -f2)heroku config:set ADMIN_JWT_SECRET=$(cat .env | grep ADMIN_JWT_SECRET | cut -d= -f2)heroku config:set JWT_SECRET=$(cat .env | grep -w JWT_SECRET | cut -d= -f2) 맥 리눅스의 경우는 아래도 따라 쓰기heroku config:set APP_KEYS=$(openssl rand -base64 32)heroku config:set API_TOKEN_SALT=$(openssl rand -base64 32)heroku config:set ADMIN_JWT_SECRET=$(openssl rand -base64 32)heroku config:set JWT_SECRET=$(openssl rand -base64 32) pg노드 모듈 설치npm install pg --save 지금까지 상황 Git 커밋git add .git commit -m \"Update database config\" yarn.lock 파일 업데이트yarn install yarn.lock 파일 git commitgit add yarn.lockgit commit -m \"Updated Yarn lockfile\" 배포git push heroku HEAD:main 배포 페이지 열고 싶으면heroku open마치며 참고로 배포 이후에는 로그인해서 직접 데이터 추가하는 것이 불가능하다. 기본 데이터 설계한 거는 로컬에서 끝내놓은 다음에 배포하면 될 것.Reference https://strapi.io/blog/deploying-a-strapi-api-on-heroku https://docs.strapi.io/developer-docs/latest/setup-deployment-guides/deployment/hosting-guides/heroku.html" }, { "title": "Nano ID, Object.values()", "url": "/posts/TIL-nanoId-220519/", "categories": "TIL, Library, JavaScript", "tags": "", "date": "2022-05-19 00:00:00 +0900", "snippet": "Nano ID Github 링크 랜덤으로 키값을 생성해주는 라이브러리 코드 정말 간단. 아래가 끝import { nanoid } from 'nanoid'model.id = nanoid() //=&gt; \"V1StGXR8_Z5jdHi6B-myT\"Object.values() 객체에서 values값들만 배열로 리턴. 사용했던 이유는 redux에서 ...", "content": "Nano ID Github 링크 랜덤으로 키값을 생성해주는 라이브러리 코드 정말 간단. 아래가 끝import { nanoid } from 'nanoid'model.id = nanoid() //=&gt; \"V1StGXR8_Z5jdHi6B-myT\"Object.values() 객체에서 values값들만 배열로 리턴. 사용했던 이유는 redux에서 가져온 전역 데이터 값이 Object로 들어와서 이것을 Array로 리턴하기 위해서 사용. MDN 예제는 아래와 같음.const object1 = { a: 'somestring', b: 42, c: false};console.log(Object.values(object1));// expected output: Array [\"somestring\", 42, false]Reference https://github.com/ai/nanoid/ https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/values" }, { "title": "라이센스 선택하기, 아스키 코드로 영문자 쓰기, 옵셔널 체이닝이 뭐였지?, immer, a11y lint, Faker", "url": "/posts/TIL-license-toUpperCase-charCodeAt-immer-placeholder-220518/", "categories": "TIL, Library, JavaScript, TypeScript, License", "tags": "", "date": "2022-05-18 00:00:00 +0900", "snippet": "Github 라이센스 선택하기들어가기회사에서 프로젝트를 진행하면서 라이브러리를 많이 사용하게 되었다. 별 생각 없이 라이브러리르 사용했었는데 회사에서는 그러면 안 됐다. 라이센스라는게 있기 때문이다. 전에는 자세히 알지 못하고 막 썼는데, 이제 라이센스에 대해서 신경 써야 겠다.이런 라이센스들이 있다. BSD : 소스코드 공개 X, 라이센스, 저작권...", "content": "Github 라이센스 선택하기들어가기회사에서 프로젝트를 진행하면서 라이브러리를 많이 사용하게 되었다. 별 생각 없이 라이브러리르 사용했었는데 회사에서는 그러면 안 됐다. 라이센스라는게 있기 때문이다. 전에는 자세히 알지 못하고 막 썼는데, 이제 라이센스에 대해서 신경 써야 겠다.이런 라이센스들이 있다. BSD : 소스코드 공개 X, 라이센스, 저작권 명시 GPL : GPL 코드를 사용한 경우 내 프로그램도 GPL이 됨. 프로그램 유료로 사용 가능하지만 소스코드는 무료로 모두 공개해야 함. MIT👍 : 라이선스 저작권 명시 필요. 상업적 이용 가능. 제약 조건이 느슨. (따라서 회사에서 프로젝트를 진행할 때 전부 MIT 라이센스의 라이브러리만 사용했다.) 아스키 코드로 영문자 쓰기아스키 코드? 정보 교환용 부호 체계 0과 1을 사용하는 컴퓨터에서는 결국 문자도 숫자로 기억하는 것. 문자의 인코딩 방식 중 하나가 아스키 코드 여러 프로그래밍 언어에서 사용할 수 있음 아스키 코드에서 65~90는 A~Z, 97~122는 a~z는 기본 상식이라고 함.[JS] String.prototype.charCodeAt() 이 메서드는 string을 아스키 코드로 바꿔 줌.[JS] String.prototype.toUpperCase() 이 메서드는 string 소문자를 대문자로 바꿔 줌.[TS] 옵셔널 체이닝 예전에 프로젝트 할 때 엄청 이야기했으면서 뭔지 또 까먹고 있었음. 객체 불러올 때 depth를 .으로 쓸 수 있는데 혹시 그 객체가 아직 덜 불러와져서 Type이 undefined나 null이 나는 경우가 있음. 그 때 undefined나 null타입을 추가하는 대신에 그 객체의 value 값을 불러오는 부분에 ?을 추가하면 됨 비동기 코드 작성할 때 상당히 편했었음.const abc = { aaa : {bbc : 'ccc'}}console.log(abc.aaa?.bbc)여러가지 유용한 라이브러리 a11y lint - 장애인 스크린 리더기가 잘 작동할 수 있도록 코드가 작성되어 있는지 확인하는 린터 immer - 불변성 지키면서 reducer 코드 작성할 때 편한 라이브러리 (추후에 다시 정리) Faker - 더미데이터 랜덤으로 만들어주는 라이브러리Reference https://flyingsquirrel.medium.com/github-license%EC%9D%98-%EC%A2%85%EB%A5%98%EC%99%80-%EB%82%98%EC%97%90%EA%B2%8C-%EB%A7%9E%EB%8A%94-%EB%9D%BC%EC%9D%B4%EC%84%A0%EC%8A%A4-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0-ae29925e8ff4 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/charCodeAt https://shaeod.tistory.com/228 https://jaeheon.kr/155 https://inf.run/VyTM" }, { "title": "Github 개인 저장소를 팀 저장소로 옮기기, Docker로 github repository 관리", "url": "/posts/TIL-Github-team-repository-2205017/", "categories": "TIL, Github, Docker", "tags": "", "date": "2022-05-17 00:00:00 +0900", "snippet": "Github 개인 저장소를 팀 저장소로 옮기기들어가기처음 프로젝트를 시작할 때 샘플이라고 생각해서 개인 레파지토리에 올려놓고 작업을 했는데 정식 프로젝트가 되면서 조직(팀) 저장소로 옮기게 되었다. 그런데 해본 적이 없어서 인터넷에서 찾아보며 팀 저장소로 이동 시켰다.옮기는 방법 개인 레파지토리 페이지로 들어간다. Settings 메뉴로 이동한다....", "content": "Github 개인 저장소를 팀 저장소로 옮기기들어가기처음 프로젝트를 시작할 때 샘플이라고 생각해서 개인 레파지토리에 올려놓고 작업을 했는데 정식 프로젝트가 되면서 조직(팀) 저장소로 옮기게 되었다. 그런데 해본 적이 없어서 인터넷에서 찾아보며 팀 저장소로 이동 시켰다.옮기는 방법 개인 레파지토리 페이지로 들어간다. Settings 메뉴로 이동한다. 쭉 아래로 내리면 Danger Zone을 볼 수 있다. 거기에서 Transfer ownership의 Transfer를 누른다. 옮길 계정 아이디나 조직 이름을 입력한다. 아래에 레파지토리 이름을 다시 재입력하고 trasfer this repository 버튼을 클릭한다. 끝!마무리생각보다 간단했다.그 이후는 조직에 있는 레파지토리에서 권한을 받은 후에 다시 본인 레파지토리로 fork해서 작업하면 된다.Docker에서 Github repository를 관리하기?!들어가기CTO님께서 도커를 통해서도 각각의 Repository를 의존성 없이 관리할 수 있다는 것을 알려주시고, 직접 보여주셨다.뭔가 각 프로젝트가 컨테이너마다 나뉘어서 독립적으로 돌아가는 부분이 굉장히 멋있어 보였다.(사실 도커로 관리하는 진짜 목적은 node.js 버전의 호환성이라던지 Github 계정이 여러 개인 경우 각 프로젝트마다 다른 계정을 설정해 준다던지 하는 부분에서 독립 컨테이너 안에서 실행되기 때문에 한 컴퓨터에서 여러 환경을 관리할 수 있따는 장점이 더 크다.)그래서 설치!설치 및 실행 먼저 Docker 계정 만들기 요기 도커허브에서 계정을 만들 수 있다. https://hub.docker.com/login 설치하기 맥과 윈도우, 리눅스 환경 전부 설치 프로그램이 다르다. 나의 경우는 맥용 Docker Desktop 다운로드 윈도우는 여기에서 (클릭) 리눅스는 여기에서 (클릭) 로그인하고 Dev Environments에 들어와서 Create New Environment 클릭 ! Enter the Git Repository에 git Clone용 주소 붙여넣고 컨테이너 생성 ! 생성된 컨테이너에서 OPEN IN VSCODE를 누르면 vscode에서 컨테이너의 프로젝트를 확인할 수 있음. ! 마무리 나는 결국 Github 계정 세팅을 못 했는데… 나중에 해결한 후에 다시 내용 추가합시다.Reference https://velog.io/@hidaehyunlee/Github-%EA%B0%9C%EC%9D%B8-%EC%A0%80%EC%9E%A5%EC%86%8C%EB%A5%BC-%ED%8C%80-%EC%A0%80%EC%9E%A5%EC%86%8C%EB%A1%9C-%EB%B3%80%EA%B2%BD%ED%95%98%EA%B8%B0 CTO님의 말씀… https://docs.docker.com/desktop/dev-environments/" }, { "title": "use-Gesture, react-spring", "url": "/posts/TIL-use_Gesture-react_spring-220516/", "categories": "TIL, Library, React", "tags": "", "date": "2022-05-16 00:00:00 +0900", "snippet": "use-Gesture 페이지에서 일부 컨테이너의 터치, 클릭 드래그로 슬라이드를 할 수 있는 기능을 넣으려고 했는데, 직접 구현하면 코드가 길어지고 구현하는 시간이 비효율적이라고 생각해서 검색해서 가장 많이 나오는 것으로 활용. 해당 라이브러리 예제에서도 그렇지만 TypeScript에서 사용할 때 타입 에러가 발생 useDrag()...", "content": "use-Gesture 페이지에서 일부 컨테이너의 터치, 클릭 드래그로 슬라이드를 할 수 있는 기능을 넣으려고 했는데, 직접 구현하면 코드가 길어지고 구현하는 시간이 비효율적이라고 생각해서 검색해서 가장 많이 나오는 것으로 활용. 해당 라이브러리 예제에서도 그렇지만 TypeScript에서 사용할 때 타입 에러가 발생 useDrag() 부분에서 타입 에러가 나는데 공식 홈페이지 TypeScript 예제에서도 똑같은 에러가 나오고 있음. 추후 확인해보고 Type에러 해결 예정 react-spring 애니메이션 라이브러리 start, stop 메소드를 통해 애니메이션을 쉽게 사용하도록 함Reference https://use-gesture.netlify.app/ https://react-spring.io/ https://www.howdy-mj.me/react-spring/01-introduction/" }, { "title": "react bootstrap table2 - 테이블 라이브러리", "url": "/posts/TIL-react-bootstrap-table2-220515/", "categories": "TIL, Library, React", "tags": "", "date": "2022-05-15 00:00:00 +0900", "snippet": "react bootstrap table2 마지막 업데이트가 2018년 테이블을 쉽게 만들 수 있는 라이브러리 정렬, 필터 기능 등이 탑재되어 있음. 다른 친구네 회사에서 사용했다고 해서 검색해 봄. Ant Design에서 제공하는 Table이나 MUI의 Data Grid도 너무 훌륭해서 업데이트 되고 있지 않는 라이브러리를 사용할 ...", "content": "react bootstrap table2 마지막 업데이트가 2018년 테이블을 쉽게 만들 수 있는 라이브러리 정렬, 필터 기능 등이 탑재되어 있음. 다른 친구네 회사에서 사용했다고 해서 검색해 봄. Ant Design에서 제공하는 Table이나 MUI의 Data Grid도 너무 훌륭해서 업데이트 되고 있지 않는 라이브러리를 사용할 필요는 없을 것 같음Reference https://react-bootstrap-table.github.io/react-bootstrap-table2/" }, { "title": "react-slick, 함수 호출하기 ``, array.split(), 정규 표현식", "url": "/posts/TIL-220514/", "categories": "TIL, CS, JavaScript, Library, React", "tags": "", "date": "2022-05-14 00:00:00 +0900", "snippet": "React-Slick 캐러셀을 간단하게 만들 수 있는 라이브러리 2022년 기준으로 아직도 꾸준히 업데이트 중 공식 사이트 링크, GITHUB 링크``로도 함수를 호출 할 수 있다 Styled Component나 emotion에서 사용하는 abc`` 표현은 함수를 호출하는 방법 중 하나String.prototype.split() String을...", "content": "React-Slick 캐러셀을 간단하게 만들 수 있는 라이브러리 2022년 기준으로 아직도 꾸준히 업데이트 중 공식 사이트 링크, GITHUB 링크``로도 함수를 호출 할 수 있다 Styled Component나 emotion에서 사용하는 abc`` 표현은 함수를 호출하는 방법 중 하나String.prototype.split() String을 기준으로 문자열을 나눔. Array로 return 됨정규 표현식 프로그램에서 문자열을 다룰 때 사용 이메일 규칙을 정규 표현식으로 표현하면 아래와 같음/^(([^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+(\\.[^&lt;&gt;()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/; 유효성 검사에도 사용되고 vim에서 문자를 찾을 때도 사용됨 JavaScript에서 string.match도 사용할 수 있고 RegExp.prototype.test()라는 메서드도 있음. 정규 표현식에 만족하는 유틸을 만들때 활용하기 좋음. 정규 표현식 위키 백과 링크 정규 표현식 확인 사이트 : regexr.com regexr에 들어가면 정규 표현식을 바로 확인할 수 있어서 편함" }, { "title": "변수명 짓기", "url": "/posts/TIL-Variable_name-220513/", "categories": "TIL, Coding", "tags": "", "date": "2022-05-13 00:00:00 +0900", "snippet": "Reference https://soojin.ro/blog/naming-boolean-variablesis ~~이다 / isTrue : boolean ~~하는 중 / isLoading : boolean ~~됐다 / isLoggedIn : boolean is + 동사원형 : xhas ~~를 가지고 있다 / hasGameAccount : boo...", "content": "Reference https://soojin.ro/blog/naming-boolean-variablesis ~~이다 / isTrue : boolean ~~하는 중 / isLoading : boolean ~~됐다 / isLoggedIn : boolean is + 동사원형 : xhas ~~를 가지고 있다 / hasGameAccount : boolean ~~이 유지되고 있다 / hasConnected: boolean동사원형 3인칭 단수로 쓸 것 / allowsEditing : boolean" }, { "title": "Thymeleaf, [Ant Design] 카드와 버튼 컴포넌트", "url": "/posts/TIL-thymeleaf-antd_card-antd_button-220511/", "categories": "TIL, AntDesign, Thymeleaf", "tags": "", "date": "2022-05-12 00:00:00 +0900", "snippet": "Thymeleaf Java Spring의 View Template Engine html태그를 기반으로 View를 담당.Ant Design의 Card, Button 컴포넌트 Ant Design의 공식 사이트는 설명이 아주 잘 나와 있다.Card 컴포넌트 bodyStyle prop을 사용하면 카드를 커스터마이징할 수 있다. hoverable pr...", "content": "Thymeleaf Java Spring의 View Template Engine html태그를 기반으로 View를 담당.Ant Design의 Card, Button 컴포넌트 Ant Design의 공식 사이트는 설명이 아주 잘 나와 있다.Card 컴포넌트 bodyStyle prop을 사용하면 카드를 커스터마이징할 수 있다. hoverable prop을 사용하면 hover 상태일 때 그림자 등의 상태가 변한다.Button 컴포넌트 type이라는 prop을 사용해서 모양을 정함 모양은 ‘primary, default, dashed’가 있음. ghost를 사용하면 배경이 transparent(투명)으로 바뀜 dangerprop을 사용하면 버튼들이 빨간색으로 변함 Ant Design의 기본 테마 색이 파란색으로 되어 있는데, 기본 primary색을 다른 색으로 바뀌면 버튼들 색도 다 변함 따라서 색상 관련 부분은 style로 커스터마이징 하는 것보다 기본 세팅에서 수정해주는 것이 좋음.Reference https://ant.design/components/card/#API https://ant.design/components/button/#API https://www.thymeleaf.org/" }, { "title": "React Event Handler의 이름 짓기, day.js, [TypeScript] prop 타입 정의하기", "url": "/posts/TIL-naming-dayjs-tstype-220511/", "categories": "TIL, React", "tags": "", "date": "2022-05-11 00:00:00 +0900", "snippet": "React에서 Event Handler의 이름 짓기 정확한 규칙이 있는 것은 아님 하지만 대부분 개발자들이 많이 사용하는 이름은 있음 https://blog.sonim1.com/220 https://jaketrent.com/post/naming-event-handlers-react 위 블로그에서 정리된 내용을 보면 prop에는 on## 함수...", "content": "React에서 Event Handler의 이름 짓기 정확한 규칙이 있는 것은 아님 하지만 대부분 개발자들이 많이 사용하는 이름은 있음 https://blog.sonim1.com/220 https://jaketrent.com/post/naming-event-handlers-react 위 블로그에서 정리된 내용을 보면 prop에는 on## 함수의 이름에는 handle##로 접두사를 붙여서 사용되는 것 같음 또한 handleClick 같은 형식으로 만들어버리면 onClick과 겹치기 때문에 다른 단어를 사용하는 것이 좋음. (오늘 useState를 쓰면서 이름이 setTimeout이 되버렸는데 보자마자 다른 setTimeout과 겹친다는 걸 깨닫고 이름을 바꾸었다.) day.js JavaScript 날짜 라이브러리 20kb도 안되는 가벼운 라이브러리 (사이트에서 2kB라고 써 있음) 시간을 조금 더 쉽게 계산할 수 있도록 해 줌. 불러온 다음 dayjs(new Date).format() 위 같은 형식으로 dayjs안에 매개변수로 date 타입을 넣어주면 잘 작동한다. ‘date’타입이 아니더라도 \"2022-02-11\" 처럼 string 타입을 넣어줘도 돼서 편함 공식사이트 링크TypeScript에서 prop의 타입을 정의할 때 (React, Next에서…) 부모 컴포넌트에서 자식 컴포넌트로 prop을 넘겨줄 때 TypeScript에서는 타입을 정의해 줘야 한다. 타입을 하나하나 지정해줘도 되고, 보통은 Type Aliases와 Inteface를 사용한다. props을 넘기고 여기에 모든 prop의 type을 정해주면 더 짧은 코드로도 사용할 수 있다.import {ReactElement} from 'react';type Props { abc : string; bbc : 'abc' | 'bbc'; ccc : number; ddd : () =&gt; void;}const Component = (props: Props): ReactElement =&gt; { return (&lt;div&gt;{props.bbc}&lt;/div&gt;);} 위 코드처럼 작성하면 prop을 모두 쓰지 않아도 된다. 다만 사용할 때마다 props.#### 처럼 props를 무조건 붙여야 해서 귀찮을 수도 있다. 다른 방법으로는 아래와 같이 쓰는 방법도 있다.import {FC} from 'react';type ComponentProps { abc : string; bbc : 'abc' | 'bbc'; ccc : number; ddd : () =&gt; void;}const Component: FC&lt;ComponentProps&gt; = (abc, bbc, ccc, ddd): ReactElement =&gt; { return (&lt;div&gt;{abc}&lt;/div&gt;)} react의 FC를 컴포넌트 자체에 타입으로 지정해 줄 떄 제네릭에 타입을 지정해줄 수 있다. 이렇게 쓰면 처음에 prop들을 일일히 써 주어야 하지만 나중에 사용할 때는 바로 prop을 쓰기만 하면 되니까 편하다. 위 방법과 아래 방법 중에 뭐가 더 좋다고 말하기는 어렵기 때문에 잘 생각해보고 편한 방법을 쓰는 것이 좋을 것임. 그런데 내가 위의 방법을 사용하는 이유는 Visual Studio Code의 react snippet 익스텐션에서 tsrafce라는 명령어를 치면 위의 방식으로 자동 입력되어 있다. 그래서 위 방법을 이용.Reference https://blog.sonim1.com/220 https://jaketrent.com/post/naming-event-handlers-react https://day.js.org/" }, { "title": "[Ant Design] useBreakpoint, Sider 옵션", "url": "/posts/TIL-antd220510/", "categories": "TIL, AntDesign", "tags": "", "date": "2022-05-10 00:00:00 +0900", "snippet": "useBreakpoint HookuseBreakpoint Ant Design의 Grid 안에는 useBreakpoint 훅이 들어있다. useBreakpoint Hook 안에 다시 xs, sm, md, lg, xl, xxl로 브레이크 포인트가 지정되어 있어서 Hook을 통해 간단하게 브라우저 사이즈에 따른 레이아웃 옵션을 줄 수 있다.사용하기 G...", "content": "useBreakpoint HookuseBreakpoint Ant Design의 Grid 안에는 useBreakpoint 훅이 들어있다. useBreakpoint Hook 안에 다시 xs, sm, md, lg, xl, xxl로 브레이크 포인트가 지정되어 있어서 Hook을 통해 간단하게 브라우저 사이즈에 따른 레이아웃 옵션을 줄 수 있다.사용하기 Grid import 하기 useBreakpoint 변수에 집어넣기 크기도 변수에 집어넣기 (ex. lg, xs, sm…)import { Grid, Tag } from 'antd';const { useBreakpoint } = Grid;const Component = () =&gt; { const {lg} = useBreakpoint(); const myFontSize = lg ? '36px' : '24px'; return ( &lt;Text type={\"secondary\"} style={{fontSize: myFontSize}}&gt;Message to {userName}&lt;/Text&gt; )}Sider를 숨기면 토글 버튼이 자동 추가! Sider의 collapsedWidth 옵션이 있다. 이 옵션의 넓이를 0으로 설정해주면 Sider가 보이지 않게 되고 다시 보이게 하는 토글 버튼이 생긴다. 이 토글 버튼을 숨기고 싶다면 trigger=\"null\"이라는 옵션을 주면 사라짐!Reference https://ant.design/components/layout/#Layout.Sider https://ant.design/components/grid/#components-grid-demo-useBreakpoint" }, { "title": "react-intl, next-i18next, next-compose-plugins", "url": "/posts/TIL-locale-module-220509/", "categories": "TIL, Next, Locale", "tags": "", "date": "2022-05-09 00:00:00 +0900", "snippet": "웹 사이트, 프로그램 다중언어 지원하기들어가기 다중언어를 지원하는 프로젝트를 진행하기 위해서 방법을 생각하고 있었다. 전역 상태로 locale 값을 받고 locale에 따라 서로 다른 상수를 출력하려고 생각을 하고 있었다. 그런데 컴퓨터나 스마트폰의 언어에 따라서 자동으로 locale를 변경하도록 구현하는 부분이 시간이 오래 걸릴 것 같았다. ...", "content": "웹 사이트, 프로그램 다중언어 지원하기들어가기 다중언어를 지원하는 프로젝트를 진행하기 위해서 방법을 생각하고 있었다. 전역 상태로 locale 값을 받고 locale에 따라 서로 다른 상수를 출력하려고 생각을 하고 있었다. 그런데 컴퓨터나 스마트폰의 언어에 따라서 자동으로 locale를 변경하도록 구현하는 부분이 시간이 오래 걸릴 것 같았다. 그래서 라이브러리를 찾아 보았다.다중언어 로케일 라이브러리 React-intl next-i18next 위 두가지가 좀 유명한 것 같다. react-intl이 유명한데 숫자, 날짜, 포맷팅까지 로케일을 지원해서 편리한 것 같다. next-i18next는 Next.js의 SSR의 경우에도 로케일을 잡아주어 Next.js와 함께 쓸 때 좋은 것 같았다. 따라서 next-i18next 라이브러리를 사용하기로 했다.next-i18next설치 yarn add next-i18next로 설치 public - locales - 원하는 언어 (en) - common.json 원하는 언어 폴더 만들고 그 아래 원하는 메뉴를 JSON파일로 만든다. 프로젝트 세팅 next-i18next.config.js module.exports = {i18n: { defaultLocale: 'en', locales: ['en', 'ko'],},}; next.config.js const { i18n } = require('./next-i18next.config');module.exports = {i18n,}; 이렇게 하면 되는데 기존에 사용하는 모듈이 이미 있어서 next-compose-plugins을 사용해서 두 모듈을 하나로 합쳐줬다. 아래처럼 const withPlugins = require('next-compose-plugins');const withBundleAnalyzer = require('@next/bundle-analyzer')({ enabled: process.env.ANALYZE === 'true',});const { i18n } = require('./next-i18next.config');module.exports = withPlugins([withBundleAnalyzer], { i18n }); withPlugins([])의 배열 안이 아니라 2번째 인자로 i18n을 넣어야한다. 나는 이것 때문에 1시간을 헤맸다. _app 파일에 appWithTranslation 추가 import { appWithTranslation } from 'next-i18next'; const MyApp = ({ Component, pageProps }) =&gt; &lt;Component {...pageProps} /&gt;; export default appWithTranslation(MyApp); serverSideTranslations 추가 import { serverSideTranslations } from 'next-i18next/serverSideTranslations'; export async function getStaticProps({ locale }) { return { props: { ...(await serverSideTranslations(locale, ['common', 'footer'])), // Will be passed to the page component as props }, }; } getStaticProps라고 정적 페이지에 비동기 데이터를 받을 때 사용하는 것인데 대충 page의 index.ts 파일에 적용하면 내 프로젝트의 경우 Layout만 삽입되어 있기 때문에 전체 적용되고, 그래서 거기에 집어 넣음. 사용하기 (useTranslation) import { useTranslation } from 'next-i18next'; export const Footer = () =&gt; { const { t } = useTranslation('footer'); return ( &lt;footer&gt; &lt;p&gt;{t('description')}&lt;/p&gt; &lt;/footer&gt; ); }; t를 사용함 괄호 안에 string으로 해당 값을 넣어주면 로케일에 맞게 출력 됨. Reference https://www.npmjs.com/package/react-intl https://myeongjae.kim/blog/2020/04/12/react-internationalization-libraries-comparison https://github.com/isaachinman/next-i18next" }, { "title": "reduce, Postman, Swagger, Sequelize, Chart.js", "url": "/posts/TIL-chartjs-220505/", "categories": "TIL, JavaScript, Postman, Swagger, Sequelize, Library", "tags": "", "date": "2022-05-05 00:00:00 +0900", "snippet": "Array.prototype.reduce() 각 배열마다 리듀서 함수르 실행하고 하나의 결과를 반영 값을 생성해서 리턴const array1 = [1, 2, 3, 4];// 0 + 1 + 2 + 3 + 4const initialValue = 0;const sumWithInitial = array1.reduce( (previousValue, cur...", "content": "Array.prototype.reduce() 각 배열마다 리듀서 함수르 실행하고 하나의 결과를 반영 값을 생성해서 리턴const array1 = [1, 2, 3, 4];// 0 + 1 + 2 + 3 + 4const initialValue = 0;const sumWithInitial = array1.reduce( (previousValue, currentValue) =&gt; previousValue + currentValue, initialValue);console.log(sumWithInitial);// expected output: 10Postman 개발한 API를 테스트하고, 테스트 결과를 공유하여 API 개발의 생산성을 높여주는 플랫폼 공식 홈페이지: https://www.postman.com/Swagger API 문서를 뽑을 때 많이 사용함. API 문서 자동화 공식 홈페이지: https://swagger.io/Sequelize JavaScript로 sql 쓸 수 있게 하는 것.ORM이란? ORM(Object-Relational Mapping) 객체지향 패러다임을 활용하여 관계형 데이터베이스의 데이터를 조작하게 하는 기술 Node.js의 대표적인 ORM이 Sequelize임지원 DB MySQL, MariaDB, PostgreSQL 등 많은 RDBMS(관계형 데이터베이트 관리 시스템)를 지원Chart.js 대시보드 만드는 라이브러리 D3.js가 더 유명하다고 함. 참고 블로그Reference https://meetup.toast.com/posts/107 https://baeharam.netlify.app/posts/Node.js/Node.js-Sequelize-%EB%8B%A4%EB%A3%A8%EA%B8%B0 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" }, { "title": "JWT, dooboo-cli, strapi, less.js ElectronJS", "url": "/posts/TIL-Dooboo-220504/", "categories": "TIL, http, ReactNative, React, Boilerplate, CSS, Style", "tags": "", "date": "2022-05-04 00:00:00 +0900", "snippet": "JWT(Json Web Token)란? Json Web Token JSON 포맷을 이용해서 사용자에 대한 속성을 저장하는 Web Token 주로 회원 인증, 정보 전달에 사용됨.JWT 구조 Header, Payload, Signature의 3부분으로 이루어짐 각 부분은 Base64Url로 인코딩 되어 표현됨Header typ, alg 두 가...", "content": "JWT(Json Web Token)란? Json Web Token JSON 포맷을 이용해서 사용자에 대한 속성을 저장하는 Web Token 주로 회원 인증, 정보 전달에 사용됨.JWT 구조 Header, Payload, Signature의 3부분으로 이루어짐 각 부분은 Base64Url로 인코딩 되어 표현됨Header typ, alg 두 가지 정보로 구성 typ: 토큰의 타입을 지정 (ex. JWT) alg: 알고리즘 방식을 지정PayLoad Claim(클래임)이 담겨 있음. Claim : 토큰에서 사용할 정보들의 조각들 (JSON 형태로 들어감) Registered Claim 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터 JWT를 간결하게 하기 위해 key는 모두 3글자로 된 String iss, sub, aud, exp, nbf, iat, jti issuer, subject, audience, expiration, not before, issued at, JWT ID Public Claim 사용자 정의 클레임 공개용 정보를 위해 사용 충돌 방지를 위해 URI 포맷을 사용함 Private Claim 사용자 정의 클래임 서버와 클라이언트 사이에 임의로 지정한 정보를 저장 Signature 서명 토큰의 인코딩, 유효성 검증을 할 떄 사용하는 암호화 코드Referencehttps://mangkyu.tistory.com/56dooboo-cli React Native를 빠르게 시작할 수 있는 보일러 플레이트 (+expo) 관련 포럼 (리엑트 네이티브 서울)Strapi REST API를 쉽고 빠르게 만들 수 있는 곳 코딩은 한 줄도 안 써도 됨 GUI Web Service 공식 사이트 : https://strapi.io/ 유튜브 : Strapi를 3분 만에 시작하기 읽어볼만한 정보 : Strapi 1년이면 풀스택을 읊는다Strapi 사용하기 설치하기 npx create-strapi-app@latest my-project 그 다음 서버 페이지가 열리면 들어가서 작업할 수 있게 됨.Less.js CSS에 Script 능력을 확장한 언어 CSS 전처리기 (Preprocessor) 공식 사이트 : https://lesscss.org/Electron.js JavaScript로 Desktop App을 컴파일 할 수 있도록 해 주는 프레임워크 Slack, VSCODE 등 ElectronJS로 제작되었다고 함. 공식 사이트: https://www.electronjs.org/Referencehttps://mangkyu.tistory.com/56" }, { "title": "Compound Component Design Pattern 외 기타 용어", "url": "/posts/TIL-Compound_Component_Design_Pattern-220503/", "categories": "TIL, CS, React, DesignPattern, PostCSS, JavaScript", "tags": "", "date": "2022-05-03 00:00:00 +0900", "snippet": "Compound Component Design Pattern 복합 컴포넌트의 디자인 패턴 Prop의 드릴을 피하고 상태 공유를 암시적으로 표시 복합 컴포넌트 : 상위 구성 요소와 하위 구성 요소가 통신할 수 있는 컴포넌트 React에서 children을 사용하면 컴포넌트를 &lt;&gt; 사이 &lt;/&gt; 열고 닫을 때 사이에 있는 내용이...", "content": "Compound Component Design Pattern 복합 컴포넌트의 디자인 패턴 Prop의 드릴을 피하고 상태 공유를 암시적으로 표시 복합 컴포넌트 : 상위 구성 요소와 하위 구성 요소가 통신할 수 있는 컴포넌트 React에서 children을 사용하면 컴포넌트를 &lt;&gt; 사이 &lt;/&gt; 열고 닫을 때 사이에 있는 내용이 해당 컴포넌트에 삽입된 부분에 들어가도록 구현할 수 있는데, 이것을 이야기 함. Reference : https://betterprogramming.pub/compound-component-design-pattern-in-react-34b50e32dea0CLI Command Line Interface 터미널처럼 커맨드를 입력해서 컴퓨터와 소통하는 방식 항상 같이 나오는 녀석으로는 GUI(Grapic User Inteface)가 있음(윈도우, 맥 같은거)PostCSS 이건 스타일 전처리기가 아님 JavaScript 도구 Style Lint, TailwindCSS 등에서 사용하는데 사용자 정의 플러그인도 만들 수 있는 장점이 있음. Reference : https://www.julian.io/articles/postcss.htmlHTML에서 Canvas API admin, dashboard에서 그래프를 그린 곳에서 처음 봄 주로 그래픽, 애니메이션, 실시간 비디오 등의 처리를 위해 사용된다고 함. 사용하기 위해서 추가적 학습이 필요 mdn web docs의 캔버스 듀토리얼 (링크)보일러 플레이트 빠르게 개발을 시작할 수 있도록 미리 세팅해 놓은 것. 사전으로는 변경 없이 계속하여 재사용할 수 있는 저작품을 말한다고 한다. (출처 : 텀즈) antd admin으로 검색했더니 바로 프로젝트가 나왔는데 이것도 보일러 플레이트라 할 수 있을 것 같음. (링크)~ (틸트) from JavaScript 자바스크립트에 이런게 있다고 들어서 깜짝 놀람. 반대로 바꿔주는 역할을 하는 것 같은데 내용 공부는 추후 you don't know javascript 책을 읽으면서 공부할 것." }, { "title": "GNB, LNB, SNB, FNB란?", "url": "/posts/TIL-gnb-lnb-snb-fnb-220502/", "categories": "TIL, Web", "tags": "", "date": "2022-05-02 00:00:00 +0900", "snippet": "들어가기 GNB를 들으면서 분명히 아는 건데 갑자기 생각이 안 났다. 이건 정리하지 않으면 안된다고 생각했다. 그래서 GNB, LNB, SNB, FNB 약자를 풀어서 써 보기로 한다.GNB (Global Navigation Bar) 홈페이지에서 주로 메인 메뉴가 되는 부분의 네비게이션을 이야기한다.LNB (Local Navigation Bar)...", "content": "들어가기 GNB를 들으면서 분명히 아는 건데 갑자기 생각이 안 났다. 이건 정리하지 않으면 안된다고 생각했다. 그래서 GNB, LNB, SNB, FNB 약자를 풀어서 써 보기로 한다.GNB (Global Navigation Bar) 홈페이지에서 주로 메인 메뉴가 되는 부분의 네비게이션을 이야기한다.LNB (Local Navigation Bar) GNB에 마우스를 올렸을 때 (Mouse Over) 나오는 네비게이션 메뉴를 말한다. 주로 서브 메뉴에 해당한다.SNB (Side Navigation Bar) 메인 메뉴, 서브 메뉴를 제외한 나머지 사이드 메뉴나 기타메뉴바 등이 이에 해당한다.FNB (Foot Navigation Bar) 맨 밑에 있는 네비게이션 사이트맵, 저작권 정보, 회사 소개 등의 메뉴가 있는 부분Reference https://chlolisher.tistory.com/62" }, { "title": "React Native가 React와 다른 점", "url": "/posts/TIL-RN-rule-layout-220501.md/", "categories": "TIL, ReactNative", "tags": "", "date": "2022-05-01 00:00:00 +0900", "snippet": "제일 큰 것 React Native는 웹을 만들기 위한 라이브러리가 아니고 앱을 만들기 위한 라이브러리 즉, html을 사용하지 않음. 따라서 jsx, tsx 부분에는 html태그가 아니라 ReactNative 컴포넌트가 들어가야 함.컴포넌트View jsx에서 div와 같은 역할을 하는 컴포넌트 블럭과 같은 것. rea...", "content": "제일 큰 것 React Native는 웹을 만들기 위한 라이브러리가 아니고 앱을 만들기 위한 라이브러리 즉, html을 사용하지 않음. 따라서 jsx, tsx 부분에는 html태그가 아니라 ReactNative 컴포넌트가 들어가야 함.컴포넌트View jsx에서 div와 같은 역할을 하는 컴포넌트 블럭과 같은 것. react-natvie에서 불러와서 사용. Text 글자를 입력하고 싶을 때는 Text 컴포넌트를 사용해야 함. &lt;Text&gt;안녕하세요!&lt;/Text&gt; 이렇게 넣으면 글자가 나옴.스타일 적용하기컴포넌트에 style prop 넣기 style={속성}을 넣어주면 CSS처럼 스타일을 적용할 수 있음. 하지만 CSS와 완전 일치하지 않음. 내부 값은 다시 Object({})로 넣어 주어야 함. style 속성 적용 부분을 외부 컴포넌트로 빼는 방법으로 작업하면 깔끔할 수 있는데, 그 경우에는 style 관련된 코드들이 자동완성되지 않음. 이렇게 했을 때 장점은 스타일을 컴포넌트에 prop으로 바로 집어 넣은 것이 아니고 따로 뺐기 때문에 스타일 속성이 많은 경우 깔끔하게 정리할 수 있고, 재사용할 수 있다는 장점이 있음. 하지만 몇몇 간단한 스타일 속성만 적용시킬 때는 컴포넌트에 prop을 바로 넣어서 사용하는 것이 나을 수도 있음. StyleSheet.create() 메서드 사용하기 StyleSheet.create() 내부에 Object를 넣어서 여러 스타일 코드들을 정리할 수 있음. 이 메서드를 사용함으로써 IDE에 있는 Style 관련 속성 자동 완성 기능을 사용할 수 있다는 장점이 있음.스타일 관련 React Native의 장점 웹에서는 스타일 관련 에러가 있어도 그걸 알려주지는 않는데, React Native에서는 스타일 관련된 에러가 있으면 바로 표시해 주어서 버그를 미리 예방하기 좋음.Components와 APIs처음에 기본 세팅에 있는 StatusBar는? Expo에서 제공하는 API 중 하나 모바일 운영체제와 소통하여 배터리, 시계 등의 상태 창을 표시하고, 속성을 줄 수 있는 APICore Components https://reactnative.dev/docs/components-and-apis React Native에서 기본으로 제공하는 코어 컴포넌트 핵심 기능들만 제공함. 이전에는 많은 기능들을 제공했었지만, 그 기능들의 유지보수를 하는데 비용이 많이 발생하고, 유저가 직접 버그를 수정해야 하는 경우까지 발생하여 지금은 유저가 직접 제공하는 API를 사용하도록 유도하고 있음. (이전에 만들었던 컴포넌트들은 이제 React Native 팀에서는 제공하지 않음.)APIs(Third Party Package) Naviagation, Date Picker등 여러 기능을 다른 유저들이 만든 API로 삽입할 수 있음. https://reactnative.dev/docs/accessibilityinfoExpo SDK Expo에서는 React Native가 예전에 제공했던 것처럼 필수적인 기능들을 쉽게 사용할 수 있도록 API로 제공하고 있음. https://docs.expo.dev/versions/latest/ 위 목록에서 필요한 것을 찾아서 사용하면 됨.Layout특징 View 컴포넌트는 display: Flex라고 생각하면 됨. 그런데 웹하고 다른 점이 웹에서 Flex 를 적용했을 때 기본이 Row(행)로 정렬되는데 React Native는 Column(열)로 정렬 됨. 그리고 사이즈가 커져서 밖으로 삐져나간다고 스크롤바가 생기지는 않음 (React Native는 웹이 아님)레이아웃 비율 맞추기 모바일은 기기마다 크기가 달라서 앱을 만들 때 직접 width, height값은 지정하지 않고 비율을 사용함 스타일 속성에 flex: 1이렇게 숫자를 주면 그게 비율이 됨 (1=100%) 만약에 View컴포넌트가 4개가 있는데 각각 스타일 속성은 flex: 1씩 지정해 주었다면 View 컴포넌트 블록 하나당 25%의 크기를 차지하게 됨. 즉, flex의 값은 비율임Reference https://nomadcoders.co/react-native-for-beginners https://reactnative.dev/docs/components-and-apis https://reactnative.dev/docs/accessibilityinfo https://docs.expo.dev/versions/latest/" }, { "title": "리엑트 네이티브 장단점, Expo를 사용한 세팅 방법", "url": "/posts/TIL-ReactNative-220428/", "categories": "TIL, ReactNative, Expo, Watchman", "tags": "", "date": "2022-04-28 00:00:00 +0900", "snippet": "React Native를 사용하는 이유React Native의 장점 React의 지식을 가지고 웹이 아닌 앱을 만들 수 있다. 안드로이드, IOS앱을 한 번에 만들 수 있다. 네이티브앱 지식이 없어도 만들 수 있다. CodePush를 이용해서 심사없이 간단한 업데이트가 가능하다 JS 코드, assets 요소를 업데이트할 수 있다...", "content": "React Native를 사용하는 이유React Native의 장점 React의 지식을 가지고 웹이 아닌 앱을 만들 수 있다. 안드로이드, IOS앱을 한 번에 만들 수 있다. 네이티브앱 지식이 없어도 만들 수 있다. CodePush를 이용해서 심사없이 간단한 업데이트가 가능하다 JS 코드, assets 요소를 업데이트할 수 있다. JavaScript를 사용한다. (웹개발자 커리어를 밟은 사람에게 장점) TypeScript도 사용한다. (JavaScript 장점 확장판)React Native의 단점 네이티브 앱보다 성능이 떨어질 수 밖에 없다. 일부 네이티브 기능은 구현이 어려울 수 있다. 플러터와 비교했을 때 스타일시트 언어까지 학습해야 해서 웹개발 지식이 부족한 경우 러닝커브가 높아질 수 있다.장단점을 정리하며 아직 직접 사용해보지 않았기 때문에 이외에도 장단점이 있을 거라고 생각하는데,법이 내용은 공부하면서 느낄 때마다 TIL에 남기면 좋을 것 같다.그 외에 모바일 앱을 개발하는 다른 선택지는? 네이티브 개발 (Objective-C, Swift) Flutter Dart라는 Google이 만든 언어를 사용한다.(TypeScript와 비슷한 느낌도 드는 언어?) 스타일링하는 방식이 다르다. (RN은 CSS같은 Flutter는 위젯에 속성을 쓰는 느낌) Web AppExpo를 사용하자!Expo를 사용하는 이유 Expo는 앱 개발, 구축, 배포를 신속하게 사용할 수 있는 도구이다. 컴퓨터에서 작업한 결과를 바로 핸드폰으로 볼 수 있다. 핸드폰에 Expo앱을 설치해야 하는 번거로움은 있지만 Xcode, 안드로이드 스튜디오를 설치하지 않아도 된다는 장점도 있다. (iOS의 경우는 맥이 아니면 Xcode는 설치도 안 되니까…) Expo를 사용하지 않는 다른 방법은? Xcode, 안드로이드 스튜디오, 자바 등을 설치해서 컴퓨터에서 확인하는 방법이 있다. Objetive-C, Swift 등 네이티브 언어와 모듈을 추가하려면 위 방법이 필수적이다. React Native는 어떤 방식으로 동작할까?1. 네이티브에서 이벤트가 발생하면2. 이벤트를 RN가 이해할 수 있도록 JavaScript코드로 변환시켜서 전달함.3. 전달받아서 반응한 다음에 다시 요청을 RN에서 보내면4. RN에서 안드로이드, iOS가 이해할 수 있도록 변환해서 요청을 보내고5. 이게 네이티브에서 처리된 다음에6. UI가 업데이트 됨.세팅하기Expo 세팅 먼저 Expo를 PC에 설치//Expo CLI 설치$ npm install --global expo-cli//출처: https://docs.expo.dev/get-started/installation/ 리눅스, 맥 사용자는 Watchman이라는 것을 설치해야 함. Watchman이 하는 역할? 파일을 감시하고 있다가 변경되었을 때 다른 작업을 트리거할 수 있음.(즉, 코드 변화를 실시간으로 반영하기 위해서 사용) $ brew install watchman// 출처 : https://facebook.github.io/watchman/docs/install#buildinstall 앱 스토어나 플레이스토어에서 ‘Expo’ (Or ‘Expo Go’)라는 앱을 설치Expo로 새로운 앱 만들기 (React Native) 아래와 같이 입력해서 새 프로젝트 생성$ expo init my-app//출처 : https://docs.expo.dev/get-started/create-a-new-app/ 실행하면 옵션을 선택하는 창이 나옴 blank를 선택해 주면 되는데 나는 TypeScript가 좋으므로 blank(TypeScript)를 선택하고 엔터를 쳤음.Expo 앱에서 확인하기 먼저 콘솔창에 expo login이라고 쳐서 로그인하고 프로젝트에서 npm start를 치면 QR코드가 뜸. expo 앱에서 로그인했으면 거기에서 바로 리스트가 뜨고 QR코드를 읽어도 됨Reference https://expo.dev/ https://facebook.github.io/watchman/docs/install#buildinstall https://reactnative.dev/docs/getting-started https://shin1303.tistory.com/entry/React-Native-%EA%B0%9C%EB%B0%9C-%EB%B0%A9%EB%B2%95-%EC%A4%91-Expo%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC https://medium.com/fm-stories/react-native-%EC%99%80-flutter%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%8B%A4%EB%A5%BC%EA%B9%8C-e9ea4a81b6d5 https://nomadcoders.co/react-native-for-beginners" }, { "title": "Vite - 빠른 번들러", "url": "/posts/TIL-vite-220412/", "categories": "TIL, Vite", "tags": "", "date": "2022-04-12 00:00:00 +0900", "snippet": "Vite를 사용하는 이유 번들링하는 속도를 빠르게 해서 빠르게 표시템플릿 vanilla, vue, react, preact, lit, svelte와 TypeScript 템플릿도 제공사용 방법 터미널에 아래와 같이 입력$ npm create vite@latest$ yarn create vite$ pnpm create vite// 중에 하나 ...", "content": "Vite를 사용하는 이유 번들링하는 속도를 빠르게 해서 빠르게 표시템플릿 vanilla, vue, react, preact, lit, svelte와 TypeScript 템플릿도 제공사용 방법 터미널에 아래와 같이 입력$ npm create vite@latest$ yarn create vite$ pnpm create vite// 중에 하나 프로젝트 이름 설정 템플릿 선택 타입스크립트 여부 선택 끝 간단하게 설치하고 빠르게 사용할 수 있다.Reference https://vitejs.dev/guide/#scaffolding-your-first-vite-project" }, { "title": "구문 오류, 논리 오류, 실행 오류", "url": "/posts/TIL-error-220411/", "categories": "TIL, CS", "tags": "", "date": "2022-04-11 00:00:00 +0900", "snippet": "구문 오류 (Syntax Error) 문법에 어긋나는 문장 때문에 발생하는 오류논리 오류 (Logical Error) 프로그램이 돌아가기는 하는데 엉터리로 동작하는 경우 컴파일, 실행은 정상적 작동 하지만 계획한 대로 작동하지 않음실행 오류 (Run-time Error) 프로그램이 종료될 정도로 치명적인 오류Reference https://...", "content": "구문 오류 (Syntax Error) 문법에 어긋나는 문장 때문에 발생하는 오류논리 오류 (Logical Error) 프로그램이 돌아가기는 하는데 엉터리로 동작하는 경우 컴파일, 실행은 정상적 작동 하지만 계획한 대로 작동하지 않음실행 오류 (Run-time Error) 프로그램이 종료될 정도로 치명적인 오류Reference https://m.blog.naver.com/eludien/221448617790" }, { "title": "파일명 컨벤션 Git 대소문자 오류 처리", "url": "/posts/TIL-naming_convention-220410/", "categories": "TIL, Convention", "tags": "", "date": "2022-04-10 00:00:00 +0900", "snippet": "케이스 스네이크 케이스 : main_menu 케밥 케이스 : main-menu 카멜 케이스: mainMenu카멜 케이스에서 대소문자를 잘못 써서 Git에 올린 후 수정할 때 git은 파일의 대소문자를 무시하여 대소문자 변경을 인식하지 못함 따라서 파일명이 컴포넌트인데 mainMenu에서 MainMenu로 변경해서 push를 해도 변경 사항이 ...", "content": "케이스 스네이크 케이스 : main_menu 케밥 케이스 : main-menu 카멜 케이스: mainMenu카멜 케이스에서 대소문자를 잘못 써서 Git에 올린 후 수정할 때 git은 파일의 대소문자를 무시하여 대소문자 변경을 인식하지 못함 따라서 파일명이 컴포넌트인데 mainMenu에서 MainMenu로 변경해서 push를 해도 변경 사항이 없다고 나옴.해결 방법git mv mainMenu.js MainMenu.js로 해결그래서 대부분 카멜 케이스를 사용하지만 이런 문제 때문에 ‘케밥 케이스’나 ‘스네이크 케이스’를 쓰는 경우도 있다는 것을 알고 있으면 될 것 같음.Referencehttps://jeonghwan-kim.github.io/dev/2020/05/18/filename.html" }, { "title": "Vim - visual mode", "url": "/posts/TIL-vim-220409/", "categories": "TIL, Vim", "tags": "", "date": "2022-04-09 00:00:00 +0900", "snippet": "Vim - Visual Mode비주얼 모드 진입하기 v를 누르면 일반 비주얼 모드로 진입 텍스트 선택 가능 수정할 때는 r 삽입할 때는 i 복사할 때는 y 잘라내기는 dVisual Line 줄 선택을 할 때 사용 V로 진입Visual Block Ctrl + c Or Ctrl + q로 진입 여러 줄을 선택할 때 사용 비주얼 블록 모드에서 ...", "content": "Vim - Visual Mode비주얼 모드 진입하기 v를 누르면 일반 비주얼 모드로 진입 텍스트 선택 가능 수정할 때는 r 삽입할 때는 i 복사할 때는 y 잘라내기는 dVisual Line 줄 선택을 할 때 사용 V로 진입Visual Block Ctrl + c Or Ctrl + q로 진입 여러 줄을 선택할 때 사용 비주얼 블록 모드에서 j나 k를 누르면 아래, 윗줄 멀티라인 선택이 됨이동 관련 hjkl 방향 (순서대로 : 좌, 하, 상, 우) {,} 문단 앞 뒤로 이동 ^,$ 현재 줄 앞 뒤로 이동Reference https://m.blog.naver.com/nfwscho/220351071053" }, { "title": "템플릿 리터럴", "url": "/posts/TIL-js_literal-220408/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-04-08 00:00:00 +0900", "snippet": "템플릿 리터럴 (Template Literal) 백틱(``)을 사용하는 문자열 \\n 같은 이스케이프 시퀀스(escape sequence)를 사용하지 않아도 줄바꿈을 할 수 있음const strEx = `HelloMy Name Is Da`;Reference 이웅모, 모던 자바스크립트 Deep Dive 자바스크립트의 기본 개념과 동작 원리, 위키북스...", "content": "템플릿 리터럴 (Template Literal) 백틱(``)을 사용하는 문자열 \\n 같은 이스케이프 시퀀스(escape sequence)를 사용하지 않아도 줄바꿈을 할 수 있음const strEx = `HelloMy Name Is Da`;Reference 이웅모, 모던 자바스크립트 Deep Dive 자바스크립트의 기본 개념과 동작 원리, 위키북스, 2020, pp.62-63" }, { "title": "이분 탐색(Binary Search)", "url": "/posts/TIL-Binary_Search-220407/", "categories": "TIL, CS", "tags": "", "date": "2022-04-07 00:00:00 +0900", "snippet": "이분 탐색이란? 순차 탐색처럼 처음부터 끝까지 하나씩 모든 데이터를 체크하여 값을 찾지 않고 탐색 범위를 절반씩 줄여가며 찾는 탐색 방법 예를 들면 1~1000까지 숫자가 있다고 할 때, 1~500, 501~1000으로 나눠서 검색 따라서 조금 더 빠르게 검색할 수 있음Reference https://satisfactoryplac...", "content": "이분 탐색이란? 순차 탐색처럼 처음부터 끝까지 하나씩 모든 데이터를 체크하여 값을 찾지 않고 탐색 범위를 절반씩 줄여가며 찾는 탐색 방법 예를 들면 1~1000까지 숫자가 있다고 할 때, 1~500, 501~1000으로 나눠서 검색 따라서 조금 더 빠르게 검색할 수 있음Reference https://satisfactoryplace.tistory.com/39" }, { "title": "React Router v6에 변경점", "url": "/posts/TIL-220406/", "categories": "TIL, React", "tags": "", "date": "2022-04-06 00:00:00 +0900", "snippet": "들어가기 이전에 프로젝트를 진행하면서 React Router가 6버전으로 올라가면서 많은 부분에서 변경이 있었다는 이야기를 들었다. 이번에 개인 프로젝트를 새로 진행하면서 6버전으로 프로젝트를 진행했는데 생각보다 많이 달라서 사용하면서 정리했던 부분을 TIL에 남긴다.바뀐 부분Switch대신 Routes를 사용 Route를 감싸고 매칭되는 pat...", "content": "들어가기 이전에 프로젝트를 진행하면서 React Router가 6버전으로 올라가면서 많은 부분에서 변경이 있었다는 이야기를 들었다. 이번에 개인 프로젝트를 새로 진행하면서 6버전으로 프로젝트를 진행했는데 생각보다 많이 달라서 사용하면서 정리했던 부분을 TIL에 남긴다.바뀐 부분Switch대신 Routes를 사용 Route를 감싸고 매칭되는 path를 보내는 역할을 했던 Switch에서 Routes를 쓰도록 변경되었다.exact 옵션이 사라짐 이전에 해당 컴포넌트 하나만 보여주기 위해서 Route에 exact prop을 넣어주면 되었는데 그런 옵션이 사라졌다. 대신 경로(path) 뒤에 /*을 삽입해 주는 방법을 사용.라우트에 컴포넌트 삽입 방법 변경 이전에는 component prop에 넣어줬는데 element로 변경그 외 useHistory를 통해 페이지를 보내거나 변경하는 식의 기능들이 전부 useNavigate로 변경되었다. useHistory는 객체 형태였지만 useNavigate는 함수 형태 history.push(/user/${id});, naviagate('/');Reference https://reactrouter.com/docs/en/v6/getting-started/overview https://velog.io/@ksmfou98/React-Router-v6-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EC%A0%95%EB%A6%AC" }, { "title": "Hateoas", "url": "/posts/TIL-hateoas-220405/", "categories": "TIL, REST_API", "tags": "", "date": "2022-04-05 00:00:00 +0900", "snippet": "REST API REpresentational State Transfer 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미 URI(Uniform Resource Identifier)을통해 자원을 명시하고 HTTP Method(POST, GET, PUT, DELETE)를 통해 자원에 대한 CRUD Oper...", "content": "REST API REpresentational State Transfer 자원을 이름(자원의 표현)으로 구분하여 해당 자원의 상태(정보)를 주고 받는 모든 것을 의미 URI(Uniform Resource Identifier)을통해 자원을 명시하고 HTTP Method(POST, GET, PUT, DELETE)를 통해 자원에 대한 CRUD Operation을 적용하는 것Hateoas Hypermedia As The Engine Of Application State 애플리케이션의 상태를 관리하기 위해 하이퍼미디어(링크)를 사용한다는 것 즉, 클라이언트와 서버가 동적인 상호작용이 가능하도록 하는 것을 의미 링크를 통해서 애플리케이션 상태 전이가 가능해야 하고 링크에 자기 자신에 대한 정보가 담겨야 한다. (요청에 필요한 URI를 응답에 포함시켜 반환) 예시//출처 : https://wonit.tistory.com/454{ \"data\": { // HAL JSON의 리소스 필드 \"id\": 1000, \"name\": \"게시글 1\", \"content\": \"HAL JSON을 이용한 예시 JSON\" }, \"_links\": { // HAL JSON의 링크 필드 \"self\": { \"href\": \"http://localhost:8080/api/article/1000\" // 현재 api 주소 }, \"profile\": { \"href\": \"http://localhost:8080/docs#query-article\" // 해당 api의 문서 }, \"next\": { \"href\": \"http://localhost:8080/api/article/1001\" // article 의 다음 api 주소 }, \"prev\": { \"href\": \"http://localhost:8080/api/article/999\" // article의 이전 api 주소 } }}Reference https://wonit.tistory.com/454 https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html https://joomn11.tistory.com/26" }, { "title": "타입 단언 as(복습), as const, 상수와 리터럴", "url": "/posts/TIL-asConst_/", "categories": "TIL, TypeScript", "tags": "", "date": "2022-04-04 00:00:00 +0900", "snippet": "타입 단언 as 컴파일러가 추론하는 것이 아닌 내가 타입을 단언하도록 사용 지난 번 정리처럼 &lt;Element&gt;event.target 형식으로도 사용할 수 있고 as를 사용해서 event.target as Element로 사용할 수도 있음.상수(Constant)와 리터럴(Literal)상수(Constant) 변하지 않는 변수 cons...", "content": "타입 단언 as 컴파일러가 추론하는 것이 아닌 내가 타입을 단언하도록 사용 지난 번 정리처럼 &lt;Element&gt;event.target 형식으로도 사용할 수 있고 as를 사용해서 event.target as Element로 사용할 수도 있음.상수(Constant)와 리터럴(Literal)상수(Constant) 변하지 않는 변수 const가 그 예리터럴(Literal) 데이터 자체를 이야기 함 변수에 넣는 변하지 않는 데이터를 이야기 함. TypeScript에서는 String, number, boolean이 이에 해당as const - 리터럴 타입의 추론 범위를 줄이자const greeting1 = 'Hello, World!'; // \"Hello, World!\"로 추론let greeting2 = 'Hello, World!'; // string으로 추론// 출처 : https://velog.io/@logqwerty/Enum-vs-as-const TypeScript에서는 타입을 지정하지 않아도 JavaScript처럼 타입을 추론한다. 위 코드를 보면 const를 썼을 때는 'Hello, World!'로 타입을 추론했지만 아래 코드는 string으로 추론했다. 그 이유는 let을 썼기 때문에 greeting2의 값은 언제든지 다른 string으로 바뀔 수 있기 때문이다 이 때 추론 범위를 넓은 범위의 string가 아닌 좁은 범위의 'Hello, World!'로 추론하도록 as const를 사용할 수 있다.let greeting2 = 'Hello, world!' as const;// 출처 : https://velog.io/@logqwerty/Enum-vs-as-const 위처럼 작성해 줌으로서 let을 사용했지만 type은 'Hello, World!'로 좁혀졌다. 하지만 이 경우는 그냥 `const greeting1 = ‘Hello, World!’; 으로 사용하면 편하다. 그럼 as const는 필요 없는 것일까? Object와 Array의 경우를 생각해 보면 const를 사용해도 내부를 변경할 수 있기 때문에 타입이 좁혀지지 않을 것이라고 추측할 수 있다.const members = { first: '철수', //string second: '영희', //string} 이 경우에 as const를 사용하면 타입이 '철수'와 '영희'로 고정된다.const members = { first: '철수', second: '영희',} as const;기타 https://velog.io/@logqwerty/Enum-vs-as-const 위 포스트를 읽으면서 enum과 const enum에 대해서도 다시 한 번 정리해 보면 좋을 것 같다고 생각한다.Reference https://velog.io/@dltjdwls100/TIL-Typescript-is%EC%99%80-as-%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90 https://velog.io/@logqwerty/Enum-vs-as-const https://velog.io/@youn0097/TypeScript-4-%EB%A6%AC%ED%84%B0%EB%9F%B4-%ED%83%80%EC%9E%85" }, { "title": "Object freeze(), seal()", "url": "/posts/TIL-ObjectFreezeSeal-220403/", "categories": "TIL, JavaScript, Object", "tags": "", "date": "2022-04-03 00:00:00 +0900", "snippet": "Object.seal() 객체를 밀봉 새로운 속성을 추가할 수 없게 됨 Object.seal(object1)의 형식으로 사용 하지만 속성의 값은 변경 가능const object1 = { value1: 32, value2: 24,}Object.seal(object1);object1.value1 = 22;console.log(object...", "content": "Object.seal() 객체를 밀봉 새로운 속성을 추가할 수 없게 됨 Object.seal(object1)의 형식으로 사용 하지만 속성의 값은 변경 가능const object1 = { value1: 32, value2: 24,}Object.seal(object1);object1.value1 = 22;console.log(object1.value1);// expected output : 22Object.freeze() 객체를 동결 더 이상 속성을 변경할 수도 추가할 수도 없게 됨 Object.freeze(object1) 형식으로 사용Reference https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/seal https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" }, { "title": "Container & Presentational Component Pattern", "url": "/posts/TIL-Container_Presentational_component_220402/", "categories": "TIL, DesignPattern", "tags": "", "date": "2022-04-02 00:00:00 +0900", "snippet": "Container &amp; Presentational Component Pattern의미 데이터 처리와 출력을 분리하는 패턴Container Component Container Component에서는 로직 처리만 담당Presentaional Component Presentational Component에서는 보여지는 부분만 담당 ...", "content": "Container &amp; Presentational Component Pattern의미 데이터 처리와 출력을 분리하는 패턴Container Component Container Component에서는 로직 처리만 담당Presentaional Component Presentational Component에서는 보여지는 부분만 담당 markup과 styling view에 필요한 state는 가지고 있을 수 있음. 장단점 기능과 디자인 부분을 분리하였기 때문에 유지보수 시 구분하기 쉽다 재사용성을 높일 수 있다 일부 컴포넌트에서는 분리하는 것이 더 작업을 복잡하게 할 수 있다Reference https://velog.io/@holim0/React-Design-Pattern" }, { "title": "배열 필터링 - array.prototype.filter()", "url": "/posts/TIL-array_filter-220401/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-04-01 00:00:00 +0900", "snippet": "array.prototype.filter() filter() 메서드의 배개변수로는 콜백함수가 들어감 return에는 필터 통과 조건을 작성 필터에서 통과하는 녀석들만 배열로 다시 출력const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const resul...", "content": "array.prototype.filter() filter() 메서드의 배개변수로는 콜백함수가 들어감 return에는 필터 통과 조건을 작성 필터에서 통과하는 녀석들만 배열로 다시 출력const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];const result = words.filter(word =&gt; word.length &gt; 6);console.log(result);// expected output: Array [\"exuberant\", \"destruction\", \"present\"]이전 프로젝트에서 사용import filterSearchProps from './filterSearch.type';const filterSearch = ({ inputValue = '', datas }: filterSearchProps) =&gt; { //데이터 배열에 순서 번호 추가 (id) const plusDataNumber = datas.map((item, index) =&gt; { return { id: index, key: item[0], item: item[1] }; }); //item기준으로 key값 필터링 const filter = plusDataNumber.filter(data =&gt; { return data.item.indexOf(inputValue) !== -1; }); //필터링된 값을 다시 id, key 형태로 변환 후 반환 const result: filterSearchProps['result'] = filter.map(item =&gt; { return { id: item.id, key: item.key }; }); return result;};export default filterSearch; 검색어를 받아서 필터링된 값을 출력하는 유틸 컴포넌트이다. 이전 코드는 빈 배열을 const result = [] 결과 값으로 놓고 array.map()을 사용해서 result에 push해 줬는데 array.filter()를 사용하는 것이 더 적절한 것으로 생각되어 리팩토링했다. 하지만 코드가 더 길어져 버렸는데 datas로 들어온 녀석이 2차원 배열이고, 그 배열 안에 id값이 포함이 안 되어 있는데 출력할 때는 id를 출력해야 해서 데이터 처리가 복잡해졌다. 어쨌든 받아온 데이터에 id값을 추가로 넣어주고 key값 기준으로 필터링한 후 value를 삭제하고 결과 값을 넘기는 방식으로 구현했다. 여기에서 filter를 사용했고 return안에 조건을 넣었다. return 전에 있는 코드들은 무조건 한 번씩 실행된다. array.map()과 비슷한데 새로운 배열을 반환할 때 return안에 있는 조건을 통과한 경우에만 반환되는 점이 다르다.Reference https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" }, { "title": "객체를 배열로 - Object.entries()", "url": "/posts/TIL-220331/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-03-31 00:00:00 +0900", "snippet": "Object.entries() key, value를 가지고 있는 객체를 [key, value]의 형태의 배열로 출력 Object.entries(원하는 객체) 원하는 객체를 안에 넣으면 새로운 배열로 출력해 줌. 이전 프로젝트에서 이런 방식으로 2차원 배열로 출력 시킴 (링크) 배열로 출력할 때 따로 순서에 규칙이 있지 않으므로 순서를 정렬할 필...", "content": "Object.entries() key, value를 가지고 있는 객체를 [key, value]의 형태의 배열로 출력 Object.entries(원하는 객체) 원하는 객체를 안에 넣으면 새로운 배열로 출력해 줌. 이전 프로젝트에서 이런 방식으로 2차원 배열로 출력 시킴 (링크) 배열로 출력할 때 따로 순서에 규칙이 있지 않으므로 순서를 정렬할 필요가 있다면 sort 메서드를 사용할 것.Reference https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" }, { "title": "RTK Query(리덕스 툴킷 쿼리)", "url": "/posts/TIL-RTK_Querry-220330/", "categories": "TIL, Redux, RTK", "tags": "", "date": "2022-03-30 00:00:00 +0900", "snippet": "RTK Query란 간편하게 데이터를 가져오고 캐싱하는 로직을 직접 하나하나 작성할 필요가 없음. RTK Query는 Redux Toolkit에 포함된 애드온임사용 방법 API 서비스 정의// ./src/redux/service/orderSheet.tsimport { createApi, fetchBaseQuery } from '@reduxjs/t...", "content": "RTK Query란 간편하게 데이터를 가져오고 캐싱하는 로직을 직접 하나하나 작성할 필요가 없음. RTK Query는 Redux Toolkit에 포함된 애드온임사용 방법 API 서비스 정의// ./src/redux/service/orderSheet.tsimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';import OrderSheet from './orderSheet.type';// base URL과 엔드포인트들을 정의export const orderSheetApi = createApi({ reducerPath: 'orderSheetApi', baseQuery: fetchBaseQuery({ baseUrl: process.env.API_URL }), endpoints: builder =&gt; ({ getOrderSheet: builder.query&lt;OrderSheet, null&gt;({ query: () =&gt; `/data/db.json`, }), }),});export const { useGetOrderSheetQuery } = orderSheetApi; Store에 서비스 추가// ./src/redux/store.tsimport { configureStore } from '@reduxjs/toolkit';import { setupListeners } from '@reduxjs/toolkit/query';import { orderSheetApi } from './services/orderSheet';import { modalSlice } from './slices/modal';import { orderSheetSlice } from './slices/orderSheet';export const store = configureStore({ reducer: { [orderSheetApi.reducerPath]: orderSheetApi.reducer, orderSheet: orderSheetSlice.reducer, modal: modalSlice.reducer, }, middleware: getDefaultMiddleware =&gt; getDefaultMiddleware().concat(orderSheetApi.middleware),});setupListeners(store.dispatch);// RootState typeexport type RootState = ReturnType&lt;typeof store.getState&gt;;// App Dispatch typeexport type AppDispatch = typeof store.dispatch; 컴포넌트에서 쿼리 사용import React, { ReactElement, useState } from 'react';//reduximport { useAppSelector } from 'hooks';import { useGetOrderSheetQuery } from 'redux/services/orderSheet';import { useDispatch } from 'react-redux';import { renewalOpenState } from 'redux/slices/modal';//styleimport { Modal as MUIModal, Button } from '@mui/material';import CloseIcon from '@mui/icons-material/Close';import * as M from './Modal.styled';const Modal = (): ReactElement =&gt; { //redux const { data, error, isLoading } = useGetOrderSheetQuery(null); //이하 생략Reference https://raejoonee.gitbook.io/rtk-query/rtk-query https://redux-toolkit.js.org/tutorials/rtk-query#add-the-service-to-your-store" }, { "title": "Jest 스냅샷(Snapshot) 테스트", "url": "/posts/TIL_jest_snap_shot-220329/", "categories": "TIL, TEST, UI", "tags": "", "date": "2022-03-29 00:00:00 +0900", "snippet": "들어가기약 한 달 전에 Unit Test를 위해 Jest를 사용하면서 여러 가지 테스트 자동화에 대해서 알게 되었다. (해당 포스팅으로 이동)최근에는 Cypress를 사용해서 사용자 관점에서의 UI, 기능 테스트를 진행하는 방법을 배웠는데, (해당 포스팅으로 이동)그 외에도 Jest를 이용한 UI테스트가 있다고 해서 알아보았다.Jest Snapshot...", "content": "들어가기약 한 달 전에 Unit Test를 위해 Jest를 사용하면서 여러 가지 테스트 자동화에 대해서 알게 되었다. (해당 포스팅으로 이동)최근에는 Cypress를 사용해서 사용자 관점에서의 UI, 기능 테스트를 진행하는 방법을 배웠는데, (해당 포스팅으로 이동)그 외에도 Jest를 이용한 UI테스트가 있다고 해서 알아보았다.Jest Snapshot Testing 미리 찍어놓은 스냅샷과 UI 컴포넌트를 렌더링하고 찍은 스냅샷을 비교하여 일치하는 지 확인하는 UI 자동 테스트 방법.장점 자동 테스트이기 때문에 달라지는 부분이 있으면 바로 확인할 수 있다.단점 UI 변경이 자주 있는 컴포넌트일 경우 오히려 매번 수정하는 비용이 더 발생할 수 있다. 혹은 UI 변경이 전혀 없는 컴포넌트인데 테스트 코드를 작성함으로써 더 비용이 발생할 수 있다.기타 직접 사용해 보지는 않아서 다음 프로젝트 때 적절한 상황이 발생한다면 사용해 볼 예정이다.Reference https://mulder21c.github.io/jest/docs/en/next/snapshot-testing https://www.daleseo.com/jest-snapshot/" }, { "title": "e2e 테스트 - Cypress", "url": "/posts/TIL-e2e_test-220328/", "categories": "TIL, TEST, Cypress, UI", "tags": "", "date": "2022-03-28 00:00:00 +0900", "snippet": "들어가기프로그래밍을 하면서 모든 과정을 테스트할 수 없지만 잘 작동 되는지 테스트가 필요하다.하지만 일일이 눌러보며 테스트를 하는 것은 시간이 오래 걸리기 때문에 비효율적이다.그래서 Jest나 Cypress같은 툴을 이용해서 테스트 자동화를 한다.이전까지 Jest만 몇번 사용했었는데, UI테스트를 위한 Cypress를 공부하며 간단하게 정리하려고 한다...", "content": "들어가기프로그래밍을 하면서 모든 과정을 테스트할 수 없지만 잘 작동 되는지 테스트가 필요하다.하지만 일일이 눌러보며 테스트를 하는 것은 시간이 오래 걸리기 때문에 비효율적이다.그래서 Jest나 Cypress같은 툴을 이용해서 테스트 자동화를 한다.이전까지 Jest만 몇번 사용했었는데, UI테스트를 위한 Cypress를 공부하며 간단하게 정리하려고 한다.사용 방법설치$npm install cypress --save-dev//아니면$yarn add cypress --devCypress 열기$./node_modules/.bin/cypress open 터미널에 입력하면 cypress 창이 뜬다.파일명 원본파일.spec.js테스트 하기 describe('테스트 이름', 콜백함수) 메서드를 사용해 시작 beforeEach(콜백함수) 메서드로 세팅 cy.visit('주소') 메서드로 주소 연결 it('이름', 콜백함수) 각 테스트 코드는 it 안에 작성 cy.get(\"클래스, id 선택\") 메서드를 사용해서 엘리먼트 선택 .shoud(\"조건\",\"값\") 메서드를 사용해서 확인예제describe(\"계산기 애플리케이션 테스트\", () =&gt; { beforeEach(() =&gt; { cy.visit(\"http://127.0.0.1:5500/index.html\") }); it(\"두 숫자를 더하면 덧셈 결과 값 출력\", () =&gt; { cy.get(\".digit\").contains(\"2\").click(); cy.get(\".operation\").contains(\"+\").click(); cy.get(\".digit\").contains(\"1\").click(); cy.get(\".operation\").contains(\"=\").click(); cy.get(\"#total\").should(\"have.text\", \"3\").click(); })});Reference https://docs.cypress.io" }, { "title": "[Sass] Mixin과 %", "url": "/posts/mixin-220327TIL/", "categories": "TIL, Sass, CSS", "tags": "", "date": "2022-03-27 00:00:00 +0900", "snippet": "MixinFunction과 같은 기능을 하는 Mixin Sass에서 Mixin을 사용하면 마치 Function처럼 여러 스타일을 묶어서 적용 시킬 수 있다. 또한 매개변수를 받아서 스타일을 조금씩 수정해서 적용시킬 수 있다.사용 방법@mixin banner-style($color: black) { color: $color; .banner-clo...", "content": "MixinFunction과 같은 기능을 하는 Mixin Sass에서 Mixin을 사용하면 마치 Function처럼 여러 스타일을 묶어서 적용 시킬 수 있다. 또한 매개변수를 받아서 스타일을 조금씩 수정해서 적용시킬 수 있다.사용 방법@mixin banner-style($color: black) { color: $color; .banner-close { background-color: gray; }}button { @include banner-style(red);} 선언할 때는 @mixin을 사용해서 선언 사용할 때는 @include 이름(매개변수)로 사용하고 매개변수가 없을 경우 괄호 생략 가능 :을 사용해서 매개변수의 기본값을 설정할 수 있음 type-of 메서드를 사용하면 유효성 검사도 가능 @if (type-of($color) == color) { color: $color;} 위 예제는 $color가 컬러 값이 맞는 경우 출력하는 IF문 ’%’와 ‘extend’Mixin과 비슷하지만 전달인자가 없을 때는 % Mixin과 비슷하게 함수처럼 사용 가능 Mixin과 차이라면 css로 컴파일될 때 비슷한 것들은 알아서 묶어서 써 줌 그리고 사용 방법도 조금 다름사용 방법%btn-style-18 { width: 180px;}.portal-btn { @extend %btn-style-18;} %이름{}형태로 선언 @extend %이름으로 불러올 수 있음Reference https://edu.goorm.io/lecture/25681/김버그의-ui-개발-부트캠프-경력같은-신입으로-레벨업 https://sass-lang.com/documentation/at-rules/mixin https://sass-lang.com/documentation/at-rules/extend" }, { "title": "WebGL과 three.js", "url": "/posts/TIL-three-220326/", "categories": "TIL, three.js, WebGL, Web, JavaScript", "tags": "", "date": "2022-03-26 00:00:00 +0900", "snippet": "WebGL Web기반의 그래픽 라이브러리 JavaScript 프로그래밍 언어를 통해 웹에서 3D 그래픽을 사용할 수 있음.three.js 웹 브라우저에서 3D 그래픽을 사용할 수 있게 하는 JavaScript 라이브러리 WebGL기술을 사용 three 공식 홈페이지에 예제가 있는데 너무 귀엽다 링크 인터렉티브한 홈페이지, 웹 게임 등에서 활...", "content": "WebGL Web기반의 그래픽 라이브러리 JavaScript 프로그래밍 언어를 통해 웹에서 3D 그래픽을 사용할 수 있음.three.js 웹 브라우저에서 3D 그래픽을 사용할 수 있게 하는 JavaScript 라이브러리 WebGL기술을 사용 three 공식 홈페이지에 예제가 있는데 너무 귀엽다 링크 인터렉티브한 홈페이지, 웹 게임 등에서 활용되고 있음.Reference https://www.khronos.org/webgl/ https://threejs.org" }, { "title": "그리드 시스템 (Grid System)", "url": "/posts/TIL_Grid/", "categories": "TIL, CSS, Figma, SASS", "tags": "", "date": "2022-03-25 00:00:00 +0900", "snippet": "그리드 시스템 (Grid System)용어 unit : 그리드 한 칸의 크기를 이야기 함. gutter : unit 사이의 거리를 gutter라고 함 (사실은 유닛 좌+우 값) column : gutter + unit은 column column의 모양은 다음과 같음 -&gt; [gutter][unit][gutter] = colum...", "content": "그리드 시스템 (Grid System)용어 unit : 그리드 한 칸의 크기를 이야기 함. gutter : unit 사이의 거리를 gutter라고 함 (사실은 유닛 좌+우 값) column : gutter + unit은 column column의 모양은 다음과 같음 -&gt; [gutter][unit][gutter] = column margin : css의 마진을 이야기하는 것이 아니고 왼쪽, 오른쪽 마지막 컬럼의 여백을 이야기 함. 즉 마진은 여기임 (6column이라고 했을 때) -&gt; [margin][column][column][column][column][column][column][margin] 그리드 시스템을 봤을 때 체크해야 할 것 컬럼은 몇 개? 컬럼 안의 유닛 사이즈는 몇 픽셀(or %)? 거터는 몇 픽셀?피그마에서 그리드 레이아웃 확인하기 Ctrl + G를 누르면 그리드 레이아웃 화면을 확인할 수 있음.Reference https://edu.goorm.io/lecture/25681/김버그의-ui-개발-부트캠프-경력같은-신입으로-레벨업" }, { "title": "디자인 시스템 - Storybook(스토리북)", "url": "/posts/TIL_Storybook-220324/", "categories": "TIL, Stroybook", "tags": "", "date": "2022-03-24 00:00:00 +0900", "snippet": "사용하는 이유? 협업을 통해 프로그래밍을 할 때 ‘CI(Continuous Integration)’이 중요하다. 서로 다른 작업을 할 때 버전이 멀어지지 않도록 지속적으로 통합해야 한다는 이야기다. 또한 컴포넌트를 분리하여 재사용이 가능한 코드를 작성하는 것이 중요하다. 스토리북은 재사용이 가능한 ‘UI컴포넌트’를 구축하여 디자이너와 개발자 모두...", "content": "사용하는 이유? 협업을 통해 프로그래밍을 할 때 ‘CI(Continuous Integration)’이 중요하다. 서로 다른 작업을 할 때 버전이 멀어지지 않도록 지속적으로 통합해야 한다는 이야기다. 또한 컴포넌트를 분리하여 재사용이 가능한 코드를 작성하는 것이 중요하다. 스토리북은 재사용이 가능한 ‘UI컴포넌트’를 구축하여 디자이너와 개발자 모두에게 적절한 가이드와 협업을 할 수 있도록 도움을 준다.사용 방법 공식 홈페이지 사용 방법을 확인할 수 있다. 추후 사용해본 후 다시 TIL 포스트를 작성할 예정이다.Reference https://storybook.js.org/tutorials/design-systems-for-developers/react/ko/introduction/" }, { "title": "JavaSciprt - BigInt", "url": "/posts/TIL-bigint-220323/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-03-23 00:00:00 +0900", "snippet": "BigInt지원 버전 IE : X chrome : 67이상 safari : 14이상 Samsung Internet : 9.2이상BigInt란? 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형사용 방법 숫자 뒤에 n을 붙이거나 BigInt(\"234\"); 식으로 문자열을 가지고 만들 수 있음const bigint = 123456779128...", "content": "BigInt지원 버전 IE : X chrome : 67이상 safari : 14이상 Samsung Internet : 9.2이상BigInt란? 길이의 제약 없이 정수를 다룰 수 있게 해주는 숫자형사용 방법 숫자 뒤에 n을 붙이거나 BigInt(\"234\"); 식으로 문자열을 가지고 만들 수 있음const bigint = 1234567791283912839182938123981293812938128319328n;const bigint2 = BigInt(\"234023948239048293084902384092384902834902830498239048230948\");장점 Number 타입보다 더 긴 숫자를 다룰 수 있음.Reference https://ko.javascript.info/bigint" }, { "title": "Mutable과 Immutable", "url": "/posts/TIL_mutable/", "categories": "TIL, CS, JavaScript", "tags": "", "date": "2022-03-22 00:00:00 +0900", "snippet": "Mutable의미생성된 이후에 상태가 변경될 수 있는 객체예시JavaScript에서는 Object와 Array가 있음Immutable의미생성된 이후에 상태가 변경되지 않는 객체예시JavaScript에서는 객체, 배열을 제외한 모두사용 이유 성능을 향상시키기 위해 메모리 사용을 줄이기 위해Reference https://poiemaweb.com/j...", "content": "Mutable의미생성된 이후에 상태가 변경될 수 있는 객체예시JavaScript에서는 Object와 Array가 있음Immutable의미생성된 이후에 상태가 변경되지 않는 객체예시JavaScript에서는 객체, 배열을 제외한 모두사용 이유 성능을 향상시키기 위해 메모리 사용을 줄이기 위해Reference https://poiemaweb.com/js-immutability" }, { "title": "선언형 코드와 명령형 코드, SVG 파일을 HTML에서 다루기", "url": "/posts/TIL_svg-220321/", "categories": "TIL, CS, JavaScript, CSS, HTML", "tags": "", "date": "2022-03-21 00:00:00 +0900", "snippet": "‘명령형(imperative) 코드’와 ‘선언형 (declarative) 코드’명령형 코드 결과를 얻기 위해 단게를 작성해야 하는 코드function abc(a, b) { return a + b;}선언형 코드 CSS같은 것 결과를 얻기 위해 단계가 필요하지 않고 바로 결과를 입력하는 것 background-color: red text.r...", "content": "‘명령형(imperative) 코드’와 ‘선언형 (declarative) 코드’명령형 코드 결과를 얻기 위해 단게를 작성해야 하는 코드function abc(a, b) { return a + b;}선언형 코드 CSS같은 것 결과를 얻기 위해 단계가 필요하지 않고 바로 결과를 입력하는 것 background-color: red text.replaceAll(\" \", \"a\");SVG을 다루는 방법이미지 태그 img태그의 src로 불러오기백그라운드 이미지 삽입 백그라운드 이미지로 삽입SVG 태그 사용 &lt;svg&gt;태그를 사용해서 넣을 수 있음 배경 색을 바꾸기 위해서 fill=\"currentColor\" 이 부분을 currentColor를 사용하면 div의 색깔을 상속 받을 수 있음. (폰트처럼 사용할 수 있음) html에서 불러올 때는 icon-font를 만들어서 사용할 수 있음.아이콘 폰트 만들기사이트 접속부터 다운로드까지 icoMoon이라는 사이트에서 간단하게 만들 수 있음. 여기에서 import Icon 한 다음에 아이콘 선택 하단에 Generate Font를 누르면 아이콘 이름 설정 화면이 나옴 다운로드 누르기 전에 옆에 세팅 버튼을 눌러서 이름, Class를 설정할 수 있음. 설정에서 CSS Selector는 Use i를 선택 그리고 다운로드HTML에 적용 다운받은 파일 압축을 풀고 font파일 이동시킨 후 style.css 파일을 참고하여 스타일 적용" }, { "title": "TypeScript에서 인터페이스(Interface)와 타입 앨리어스(Type Aliases)의 차이", "url": "/posts/TIL_interface_type/", "categories": "TIL, TypeScript", "tags": "", "date": "2022-03-20 00:00:00 +0900", "snippet": "시작하기 TypeScript를 사용하기 시작하면서 객체의 타입 선언을 위해 Interface와 Type을 사용하고 있다. 그런데 막상 두 개는 무슨 차이가 있는 지 잘 모르면서 사용하고 있는 것 같았다. 무슨 차이가 있을까? 공식문서에서 살펴 보았다.첫 번째 확장 방식이 다르다. 인터페이스는 extends 블라블라 형태로 확장하는 반면 타입...", "content": "시작하기 TypeScript를 사용하기 시작하면서 객체의 타입 선언을 위해 Interface와 Type을 사용하고 있다. 그런데 막상 두 개는 무슨 차이가 있는 지 잘 모르면서 사용하고 있는 것 같았다. 무슨 차이가 있을까? 공식문서에서 살펴 보았다.첫 번째 확장 방식이 다르다. 인터페이스는 extends 블라블라 형태로 확장하는 반면 타입 앨리어스는 &amp;를 사용해서 확장한다//인터페이스의 경우interface Animal { name: string}interface Bear extends Animal { honey: boolean}//타입 앨리어스의 경우type Animal = { name: string}type Bear = Animal &amp; { honey: Boolean}두 번째 ‘새 속성을 추가하기 위해 다시 선언할 수 있는가?’에 대한 차이 인터페이스는 여러 번 선언해서 새 필드를 추가할 수 있지만 타입 앨리어스는 불가능//인터페이스의 경우interface Window { title: string}interface Window { //괜찮음! ts: string}//타입 앨리어스의 경우type Window = { title: string}type Window = { //ERROR!!! ts: import(\"typescript\")}세 번째 공식문서에서는 튜플, 유니언 타입을 사용하는 경우 ‘타입 앨리어스’ 를 사용하는 것이 좋다고 밝히고 있다.튜플이란? 자바스크립트에서는 없는 타입으로 ‘길이와 타입이 고정된 배열을 의미’ 아이디, 비밀번호 같은 데이터를 배열로 만들 때 정해진 형태로만 삽입할 수 있도록 사용할 수 있음.let user1: [number, string, string];user1 = [1, 'test@b41.kr', '123456789'];Reference https://www.typescriptlang.org/docs/handbook/advanced-types.html#interfaces-vs-type-aliases" }, { "title": "HTTP 메서드 Put과 Patch의 차이", "url": "/posts/TIL_http/", "categories": "TIL, HTTP", "tags": "", "date": "2022-03-19 00:00:00 +0900", "snippet": "HTTP 요청 메서드 HTTP 요청 메서드는 리소스에 수행하기 원하는 행동을 이야기 함. CRUD에는 POST(Create), GET(Read), PUT(Update), DELETE(Delete)가 있음. 그리고 Update는 다시 하나가 더 있음. 그것이 PATCHPut과 Patch의 차이 PATCH 메서드는 리소스의 부분만 수정할 때 사용...", "content": "HTTP 요청 메서드 HTTP 요청 메서드는 리소스에 수행하기 원하는 행동을 이야기 함. CRUD에는 POST(Create), GET(Read), PUT(Update), DELETE(Delete)가 있음. 그리고 Update는 다시 하나가 더 있음. 그것이 PATCHPut과 Patch의 차이 PATCH 메서드는 리소스의 부분만 수정할 때 사용 PUT 메서드는 리소스의 모든 것을 업데이트Reference https://developer.mozilla.org/ko/docs/Web/HTTP/Methods https://joshua1988.github.io/web-development/http-part1/" }, { "title": "Redux와 React Context API의 차이", "url": "/posts/TIL-context_redux/", "categories": "TIL, ContextAPI, Redux", "tags": "", "date": "2022-03-18 00:00:00 +0900", "snippet": "들어가기 어떤 회사는 Redux를 사용하고 어떤 회사는 Context API를 사용하는 것을 보면서 두 개는 무슨 차이인지 궁금해졌다. 전역 상태를 관리하기 위해서 Redux를 처음으로 배웠었는데, React Context API도 전역 상태를 관리해준다고 한다. 두 개는 같은 것이 아닌 것 같은데… 무슨 차이일까?Redux와 Context AP...", "content": "들어가기 어떤 회사는 Redux를 사용하고 어떤 회사는 Context API를 사용하는 것을 보면서 두 개는 무슨 차이인지 궁금해졌다. 전역 상태를 관리하기 위해서 Redux를 처음으로 배웠었는데, React Context API도 전역 상태를 관리해준다고 한다. 두 개는 같은 것이 아닌 것 같은데… 무슨 차이일까?Redux와 Context API의 차이 Context API는 React에서 Prop을 전달해 줄 때 자식 컴포넌트에 깊게 들어가는 경우 prop을 전달하지 않아도 모든 레벨에서 상태 값에 접근할 수 있는 방법을 제공한다. 즉, Context API는 Props 전달을 간단하게 표현하기 위한 도구이다. (drio-drilling을 피하기 위함) Context API를 사용하면서 상태를 관리할 때는 useState와 useReducer라는 Hook을 사용한다. useReducer를 사용하면 Redux처럼 상태 관리가 가능하다. 하지만 Context API나 useReducer가 React 안에 종속되어 있기 때문에 React 밖에서 사용하지 못한다는 단점이 있다. Redux는 반대로 React에 속해 있지 않기 때문에 React의 밖에서도 사용이 가능하다. 또한 상태를 업데이트할 때 이전 상태 값을 받고 업데이트하기 때문에 관리도구로 상태 추적이 가능하다. (미들웨어 사용을 통한 Redux Devtools 이용) 그리고 Redux는 여러 미들웨어를 사용해서 비동기 데이터 처리나 다른 기능들을 추가할 수 있다.상태 관리의 조건 초기 값을 저장 현재 값을 읽음 값 업데이트가 가능 Context API는 useState와 useReducer를 같이 사용했을 때 상태 관리라고 할 수 있다. 위 조건에 따라 Redux, Mobx, Zustand 등은 상태 관리라고 할 수 있음.Reference https://ko.reactjs.org/docs/context.html https://ko.redux.js.org/introduction/getting-started https://olaf-go.medium.com/context-api-vs-redux-e8a53df99b8" }, { "title": "Styled-Components에 스타일린트(stylelint) 적용하기", "url": "/posts/TIL-style_lint/", "categories": "TIL, Style-Components, Style", "tags": "lint", "date": "2022-03-17 00:00:00 +0900", "snippet": "들어가기 sass는 lint를 사용해서 통일된 스타일 코드를 유지할 수 있는데, Styled-Components에서는 방법이 없나? 라는 생각이 들어서 찾아보던 중 공식 사이트에서 ‘stylelint’를 발견! 그래서 정리합니다. stylelint 적용하기설치 stylelint 설치하기 (npm install --save-dev \\...", "content": "들어가기 sass는 lint를 사용해서 통일된 스타일 코드를 유지할 수 있는데, Styled-Components에서는 방법이 없나? 라는 생각이 들어서 찾아보던 중 공식 사이트에서 ‘stylelint’를 발견! 그래서 정리합니다. stylelint 적용하기설치 stylelint 설치하기 (npm install --save-dev \\stylelint \\stylelint-processor-styled-components \\stylelint-config-styled-components \\stylelint-config-recommended) .stylelintrc 파일을 루트에 추가하기 { \"processors\": [ \"stylelint-processor-styled-components\" ], \"extends\": [ \"stylelint-config-recommended\", \"stylelint-config-styled-components\" ] } package.json 파일에 stylelint 설정 { \"scripts\": { \"lint:css\":\"stylelint './src/**/*.js'\" }} 실행 npm run lint:css 를 입력해서 실행할 수 있음 또한 VSCode에서 stylelint 익스텐션을 설치하면 VSCode 자체에서 확인해 줌.Reference https://styled-components.com/docs/tooling#stylelint https://flamingotiger.github.io/style/styled-components-lint/" }, { "title": "콘솔창 예쁘게 꾸미기", "url": "/posts/TIL_pretty_console/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-03-16 00:00:00 +0900", "snippet": "들어가기 프론트엔드를 공부하면서 인터렉티브한 UI에 관심이 많았고, 여러 사람들의 포트폴리오에서 이런 것들을 보며 즐거움을 느꼈다. 가끔은 어떻게 만들었는지 궁금할 때도 있다. 그럴 때 하는 것이 opt + shift + i! 그런데 가끔은 정말 특이한 콘솔을 볼 때가 있다. 위 처럼 이쁜 콘솔 로그를 사용해 들어오는 개발자에게 인사를 남길 ...", "content": "들어가기 프론트엔드를 공부하면서 인터렉티브한 UI에 관심이 많았고, 여러 사람들의 포트폴리오에서 이런 것들을 보며 즐거움을 느꼈다. 가끔은 어떻게 만들었는지 궁금할 때도 있다. 그럴 때 하는 것이 opt + shift + i! 그런데 가끔은 정말 특이한 콘솔을 볼 때가 있다. 위 처럼 이쁜 콘솔 로그를 사용해 들어오는 개발자에게 인사를 남길 수 있다. 어떻게 하는 지 궁금해서 방법을 찾아 보았다.콘솔에 CSS 적용하기 console.log()를 사용해서 CSS를 출력한다. console.log()의 첫 번째 매개 변수에 %c를 쓰면 두 번째 매개 변수에 스타일을 지정할 수 있다. 아래 처럼 사용하면 된다. console.log('%c 반갑습니다!', color:white; font-size: 20px; background-color: #C08571) 그럼 이렇게 출력된다.Reference https://jungdev.tistory.com/3" }, { "title": "JavaScript에서 소수점을 더했을 때 값이 이상하다? (220318 업데이트)", "url": "/posts/TIL_decimal_point/", "categories": "TIL, JavaScript, CS", "tags": "", "date": "2022-03-15 00:00:00 +0900", "snippet": "JavaScript에서 소수점 더하기 컴퓨터는 2진법을 사용함. 0.1 + 0.3 = 0.30000000004 (?!) 컴퓨터의 부동 소수점 계산 문제 발생 소수를 2진수로 표현할 때 무한소수가 발생 무한수를 유한하게 표현하려다 보니 미세한 값들이 손실, 초과 됨. 따라서 계산 오류가 발생 원화는 괜찮지만 미국 달러화, 비트코인에서는 소수...", "content": "JavaScript에서 소수점 더하기 컴퓨터는 2진법을 사용함. 0.1 + 0.3 = 0.30000000004 (?!) 컴퓨터의 부동 소수점 계산 문제 발생 소수를 2진수로 표현할 때 무한소수가 발생 무한수를 유한하게 표현하려다 보니 미세한 값들이 손실, 초과 됨. 따라서 계산 오류가 발생 원화는 괜찮지만 미국 달러화, 비트코인에서는 소수점 계산 문제가 발생할 수 있음.해결법 ~~소수점 숫자의 경우 *10을 해서 정수로 바꿔서 계산한 후 다시 실수로 바꾸기 (0.1 * 10 + 0.2 * 10) / 10; 2022.03.18 추가! 아니다… *10을 곱해도 오류가 날 수 있다. 아래 방법을 쓸 것. toFixed() 메서드로 소수점 고정해 주기 (0.1 + 0.2).toFixed(1); Math객체의 메서드로 소수를 다루기 수학 라이브러리 활용하기 Reference https://www.youtube.com/watch?v=rT8P3s82–4 https://bigtop.tistory.com/47 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Math/round https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed" }, { "title": "HTTP란?", "url": "/posts/TIL_http/", "categories": "TIL, HTTP, CS", "tags": "", "date": "2022-03-14 00:00:00 +0900", "snippet": "HTTP 프로토콜이란?HTTP(Hypertext Transfer Protocol) 통신하는 규칙을 이야기 함. 기본 포트 80번 HTTP 프로토콜로 데이터를 주고 받기 위해서는 요청(Request), 응답(Response)을 받아야 함. URL(Uniform Resource Locators) 서버에 자원을 요청하기...", "content": "HTTP 프로토콜이란?HTTP(Hypertext Transfer Protocol) 통신하는 규칙을 이야기 함. 기본 포트 80번 HTTP 프로토콜로 데이터를 주고 받기 위해서는 요청(Request), 응답(Response)을 받아야 함. URL(Uniform Resource Locators) 서버에 자원을 요청하기 위해 사용하는 영문 주소HTTP 요청 메서드 주요 메서드는 GET, POST, PUT, DELETEREST API와 용어 햇갈리지 말 것. REST API는 HTTP 메서드와 URI만 가지고도 어떤 요청을 하는지 유추할 수 있는 것이 REST API의 핵심.기타 요청 메서드 HEAD : 서버 헤더 정보를 획득 OPTIONS : 서버 옵션들을 확인하기 위한 요청. CORS에서 사용(데이터를 실제로 보낼 때 빈 값을 보내면 빠르게 요청과 응답이 가능하니까 요청 때 Origin에 대한 값만 보내고 응답 때는 서버에서 허용을 하고 있는가 정보를 보냄.) 옵션과 헤드에 대해서는 더 공부해 보기https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/how-to-cors.html HTTP 상태 코드 200번대 - 성공 300번대 - 리다이렉션 400번대 - 클라이언트 에러 500번대 - 서버 에러 Reference https://joshua1988.github.io/web-development/http-part1/ https://docs.aws.amazon.com/ko_kr/apigateway/latest/developerguide/how-to-cors.html" }, { "title": "Zustand - 상태관리 라이브러리", "url": "/posts/TIL-zustand/", "categories": "TIL, Zustand", "tags": "", "date": "2022-03-13 00:00:00 +0900", "snippet": "Zusatand란? redux같은 상태 관리 라이브러리 (홈페이지 캐릭터가 너무 귀여움.) store를 쉽게 만들고 한 줄 코드로 불러올 수 있는 정도로 매우 간단사용법 npm i zustand 로 설치 import create from 'zustand' 로 create 불러오기 const useStor...", "content": "Zusatand란? redux같은 상태 관리 라이브러리 (홈페이지 캐릭터가 너무 귀여움.) store를 쉽게 만들고 한 줄 코드로 불러올 수 있는 정도로 매우 간단사용법 npm i zustand 로 설치 import create from 'zustand' 로 create 불러오기 const useStore = create(set =&gt; ({ count: 1, inc: () =&gt; set(state =&gt; ({count: state.count + 1}))}))function Couter() { const count = useStore(state =&gt; state.count) return &lt;h1&gt;{count}&lt;/h1&gt;}function Controls() { const inc = useStore(state =&gt; state.inc) return &lt;button onClick={inc}&gt;+&lt;/button&gt;} 이렇게 store를 하나 만든 다음에 그 안에 실행될 것들을 지정해 주고 값을 가져올 때는 useStore에서 바로 가져다가 쓰면 됨.장점 Redux에서 리듀서 만들고, 액션, 디스패치 이런 과정보다 훨씬 심플하고 직관적Reference https://zustand-demo.pmnd.rs" }, { "title": "컴파일과 런타임의 차이", "url": "/posts/TIL_compile_runtime/", "categories": "TIL, CS", "tags": "", "date": "2022-03-12 00:00:00 +0900", "snippet": "컴파일 소스코드를 작성하고 기계어 코드로 변환되어 실행 가능한 프로그램이 되는 과정런타임 컴파일을 마친 프로그램이 실행되고, 응용프로그램이 동작하는 때를 이야기 함Reference https://spaghetti-code.tistory.com/35", "content": "컴파일 소스코드를 작성하고 기계어 코드로 변환되어 실행 가능한 프로그램이 되는 과정런타임 컴파일을 마친 프로그램이 실행되고, 응용프로그램이 동작하는 때를 이야기 함Reference https://spaghetti-code.tistory.com/35" }, { "title": "PWA, MVC 패턴", "url": "/posts/TIL_PWA/", "categories": "TIL, DesignPattern, PWA", "tags": "", "date": "2022-03-11 00:00:00 +0900", "snippet": "PWA(Progressive Web App)프로그레시브 웹이란? 웹과 네이티브 앱의 이점을 모두 가지고 있는 앱 웹 앱은 설치하지 않아도 되는 장점이 있음. 네이티브 앱은 설치하여 오프라인에서도 사용할 수 있고, 운영체제와 더 잘 통합됨. PWA는 이런 이점을 제공할 수 있는 웹 앱을 생성할 수 있음. 요즘 보면 ‘Xbox Clou...", "content": "PWA(Progressive Web App)프로그레시브 웹이란? 웹과 네이티브 앱의 이점을 모두 가지고 있는 앱 웹 앱은 설치하지 않아도 되는 장점이 있음. 네이티브 앱은 설치하여 오프라인에서도 사용할 수 있고, 운영체제와 더 잘 통합됨. PWA는 이런 이점을 제공할 수 있는 웹 앱을 생성할 수 있음. 요즘 보면 ‘Xbox Cloud’가 ios App Store에서 금지되서 ios 버전으로 제공하는 웹앱이 이런 형태.MVC Pattern (Model-View-Controller Pattern) View : 보이는 것 Controller : 제어하는 것 (읽고, 쓰기) Model : 데이터 상태 비즈니스 로직과 화면을 구분하는 디자인 패턴 장점 유연하고 확장하기 쉽다 단점 설계 시간이 오래 걸린다. Model과 View의 완벽한 분리가 어렵다. Reference https://developer.mozilla.org/ko/docs/Web/Progressive_web_apps/Introduction https://facebook.github.io/flux/" }, { "title": "호출 스택과 이벤트 루프", "url": "/posts/TIL_call_stack_event_loop/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-03-10 00:00:00 +0900", "snippet": "호출 스택 (Call Stack) 함수가 호출되었을 때 호출 스택에 쌓이게 됨. 들어오는 순서대로 쌓이고 실행되는 순서는 반대로 호출 스택에는 Anonymous라는 가상의 전역 컨텍스트가 있음. 이 컨텍스트는 무언가가 호출되면 생기고 모든 함수가 실행되면 사라짐. 호출 스택의 이런 자료 구조 방식이 LIFO라고 함LIFO (last in, f...", "content": "호출 스택 (Call Stack) 함수가 호출되었을 때 호출 스택에 쌓이게 됨. 들어오는 순서대로 쌓이고 실행되는 순서는 반대로 호출 스택에는 Anonymous라는 가상의 전역 컨텍스트가 있음. 이 컨텍스트는 무언가가 호출되면 생기고 모든 함수가 실행되면 사라짐. 호출 스택의 이런 자료 구조 방식이 LIFO라고 함LIFO (last in, first out) 말 그대로 후입선출 나중에 들어온 데이터가 가장 먼저 나가는 자료 구조 그래서 Stack(쌓다)이라고 함.실행 컨텍스트와 이벤트 루프(Event Loop)턴 +) 테스크 큐에 setTimeout과 Promise then이 있으면 then이 더 빨리 실행 됨." }, { "title": "엔티티 코드(Entity Code)", "url": "/posts/TIL_entity/", "categories": "TIL, HTML", "tags": "", "date": "2022-03-09 00:00:00 +0900", "snippet": "HTML 엔티티 코드(Entity Code)는? 키보드로 쉽게 입력할 수 없는 문자를 표현하는데 사용. ISO-8859-1은 브라우저의 대부분의 기본 문자 집합 ISO-8859-1의 처음 128자는 ASCII 문자 집합 (숫자, 영문자, 일부 특수 문자) ISO-8859-1의 상위 부분(code 160-255)에는 서유럽 국가의 문자, 일부 특...", "content": "HTML 엔티티 코드(Entity Code)는? 키보드로 쉽게 입력할 수 없는 문자를 표현하는데 사용. ISO-8859-1은 브라우저의 대부분의 기본 문자 집합 ISO-8859-1의 처음 128자는 ASCII 문자 집합 (숫자, 영문자, 일부 특수 문자) ISO-8859-1의 상위 부분(code 160-255)에는 서유럽 국가의 문자, 일부 특수 문자가 포함 HTML Symbol Entity에는 수학 기호, 그리스 문자, 화상표 등 다양한 모양이 포함되어 있음. 꺽쇠 같은 기호(&lt;) 삽입할 때 HTML의 Element를 나타내는 꺽쇠와 헛갈릴 수 있으므로 엔티티 코드를 사용하는 것이 적합함. 엔티티 코드를 볼 수 있는 사이트 링크Referencehttps://www.w3schools.com/html/html_entities.asphttps://entitycode.comhttps://alonehistory.tistory.com/12" }, { "title": "클로저(Closure)", "url": "/posts/TIL_closure/", "categories": "TIL, JavaScript", "tags": "Closure", "date": "2022-03-08 00:00:00 +0900", "snippet": "들어가기 이전에 원티드 프리온보딩 코스에서 수업을 들으면서 간단하게 블로그에 정리했지만 너무 얕게 공부했다는 생각이 들어서 다시 정리.Scope 변수가 유효한 범위를 말함. Global Scope (전역), Local Scope (지역)가 있음.Lexical scoping 어휘적 범위 지정 Lexical : 변수가 어디에서 사용이 가능한 지 ...", "content": "들어가기 이전에 원티드 프리온보딩 코스에서 수업을 들으면서 간단하게 블로그에 정리했지만 너무 얕게 공부했다는 생각이 들어서 다시 정리.Scope 변수가 유효한 범위를 말함. Global Scope (전역), Local Scope (지역)가 있음.Lexical scoping 어휘적 범위 지정 Lexical : 변수가 어디에서 사용이 가능한 지 알기 위해서 변수가 소스코드 내 어디에서 선언되었는지 고려하는 것. 중첩된 함수는 외부 범위에서 선언한 변수에도 접근할 수 있음.function init() { var name = \"b41\"; function displayName() { alert (name); } displayName();}init(); var name은 init() 함수의 지역 변수. name은 init() 밖에서는 사용할 수 없지만 중첩된 함수 displayName()에서는 사용할 수 있음.클로저(Closure)function makeFunc() { var name = \"b41\"; function displayName() { alert(name); } return displayName; } var myFunc = makeFunc(); //myFunc변수에 displayName을 리턴함 //유효범위의 어휘적 환경을 유지 myFunc(); //리턴된 displayName 함수를 실행(name 변수에 접근) 이전 예제와 다르게 displayName() 함수를 실행하지 않고 리턴만 함. 하지만 myFunc을 실행했을 때 displayName() 함수가 실행됨. 보통 다른 언어에서는 return되었으니까 name에는 접근할 수 없다고 생각함. 하지만 JavaScript에서는 리턴하는 함수가 클로저(closure)를 형성 즉, 클로저는 함수와 함수가 선언된 Lexical 환경의 조합 재미있는 클로저 예제 1 function makeAdder(x) { var y = 1; return function(z) { y = 100; return x + y + z; }; } var add5 = makeAdder(5); var add10 = makeAdder(10); //클로저에 x와 y의 환경이 저장됨 console.log(add5(2)); // 107 (x:5 + y:100 + z:2) console.log(add10(2)); // 112 (x:10 + y:100 + z:2) //함수 실행 시 클로저에 저장된 x, y값에 접근하여 값을 계산 x, y, z의 합을 리턴하는 함수 makeAdder(x) add5, add10는 모두 클로저임. 여기에서 x, y값이 이미 정해짐 그리고 `add5(z) 실행할 때 클로저에 + z값이 추가되서 계산된 값이 리턴됨. 재미있는 클로저 예제 2var A = function() { var a = 1; var B = function() { return ++a; }; **return B;**};var outer = A();console.log(outer()); // 2console.log(outer()); // 3 outer()는 클로저 outer()를 한 번 실행하니 a = 1값에서 다시 1이 추가되었으므로 2가 리턴됨 한 번 더 실행하면 클로저가 a값을 기억하고 있다가 3을 리턴함Referencehttps://developer.mozilla.org/ko/docs/Web/JavaScript/Closures" }, { "title": "React 재조정(Reconciliation)과 key, DIFF 알고리즘", "url": "/posts/TIL_Reconciliation/", "categories": "TIL, React, JavaScript, DOM, algorithm", "tags": "", "date": "2022-03-07 00:00:00 +0900", "snippet": "들어가기 기본에 충실하자! 이전에 작성한 코드를 다시 리팩터링 하는 중 이런 코드를 보았다.array.map( x =&gt; { return ( x.length &lt; 5 &amp;&amp; &lt;div id={x.id}&gt;{x.content}&lt;/div&gt; )}) 위 코드에서 x의 length는 4보다 많았고 당연히 5번째 ...", "content": "들어가기 기본에 충실하자! 이전에 작성한 코드를 다시 리팩터링 하는 중 이런 코드를 보았다.array.map( x =&gt; { return ( x.length &lt; 5 &amp;&amp; &lt;div id={x.id}&gt;{x.content}&lt;/div&gt; )}) 위 코드에서 x의 length는 4보다 많았고 당연히 5번째 array의 의 리턴 값은 undefined가 되었을 것인데 당시에 별 생각 없이 코드를 사용했던 것 같다. 문제는 리엑트에서 key 에러가 난다는 것이다. undefined된 배열의 값들에 key가 삽입되지 않고 동일한 값이 계속 리턴되고 있었기 때문에 발생하는 오류였다. React가 변경된 값에 대해서 어떻게 작동하는 지 살펴보자.DIFF 알고리즘 (비교 알고리즘) ‘변경 내용 추적’기능처럼 렌더링 화면에서 변경 부분을 확인해서 그 부분만 변경하는 알고리즘 React에서 핵심 알고리즘이라고 할 수 있다.React 재조정(Reconciliation) 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다. 개발자가 key prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할 지 표시해 줄 수 있다. 공식 홈페이지 문서에 나와있는 재조정에 대한 내용이다. Dffing Algorithm을 통해서 O(n) 복잡도의 알고리즘 구현했다고 밝히고 있다. React에서 새롭게 렌더링이 일어나는 경우는 다음과 같다.엘리먼트의 타입이 다른 경우 루트 엘리먼트가 달라지면 그 트리를 완전히 버리고 새롭게 구축 따라서 그 자식 엘리먼트도 전부 다시 구축하게 됨. &lt;a&gt; &lt;Menu /&gt; &lt;/a&gt; //에서 아래로 바꾸면 전부 다시 렌더링 &lt;div&gt; &lt;Menu /&gt; &lt;/div&gt; 즉 Menu 컴포넌트는 사라지고 다시 마운트 될 것임. 트리를 버릴 때 DOM 노드도 같이 파괴가 되는데 그 때 componentWillUnmount()가 실행됨. 새로운 DOM 노드들이 DOM에 삽입될 때 UNSAFE_componentWillMount()가 실행되고 이어서 componentDidMount()가 실행.DOM 엘리먼트 타입이 같은 경우 같은 타입의 React Dom 엘리먼트를 비교할 때 동일한 내역은 유지하고 변경된 속성만 갱신&lt;div className=\"before\" title=\"stuff\" /&gt;//하단 엘리먼트의 className만 수정&lt;div className=\"after\" title=\"stuff\" /&gt;DOM 노드의 자식을 효율적으로 처리하자 아래 코드와 같이 자식이 변경되는 경우 React는 전부 다시 렌더링하여 안 좋은 성능을 보인다.&lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;//위 코드에서 아래와 같이 자식이 변경되면, 전부 다 다시 렌더링&lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;효율적으로 처리하는 방법 ‘Keys’ React에서 key는 자식들이 동일한 지 확인하는 이름같은 역할을 함.&lt;ul&gt; &lt;li key=\"2015\"&gt;Duke&lt;/li&gt; &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;&lt;/ul&gt;// 아래 코드로 바뀌어도 '2015'라는 이름이 지정되어 있기 때문에 다시 변경하지 않음.&lt;ul&gt; &lt;li key=\"2014\"&gt;Connecticut&lt;/li&gt; &lt;li key=\"2015\"&gt;Duke&lt;/li&gt; &lt;li key=\"2016\"&gt;Villanova&lt;/li&gt;&lt;/ul&gt; 이번에는 key를 사용해서 이름을 지정했기 때문에 위치가 변경되었어도 변경 작업을 하지 않았음. 따라서 더 빠르고 효율적으로 React가 렌더링 함. 위에서 정리한 대로 key는 이름이기 때문에 다음과 같은 규칙을 지켜야 함. 반드시 변하지 않을 것. 예상이 가능해야 함 (누군지 예상 가능한 이름) 유일해야함 (똑같은 이름이 여러개 있으면 안됨) 랜덤 함수같은 것(Math.random())을 사용하면 key를 쓰는 의미가 없음. 많이 하는 실수가 map 메서드를 돌리면서 index를 key값으로 넣어버리는 경우. key는 변하지 않는 이름이어야 하는데 index는 단지 array의 순서를 말하는 유동적인 값이기 때문에 절대 index를 key로 넣으면 안 됨.Reference https://ko.reactjs.org/docs/reconciliation.html https://meetup.toast.com/posts/134" }, { "title": "Pseudo Element, Iass, Pass, Sass", "url": "/posts/TIL_pseudo/", "categories": "TIL, HTML, CSS, 용어", "tags": "", "date": "2022-03-06 00:00:00 +0900", "snippet": "Pseudo Class (가짜 클래스, 의사 클래스, 가상 클래스, 추상 클래스) : pseudo class hover, checked 등이 해당. 외부 인자와 관련된 경우에도 스타일 적용할 수 있음. (마우스 위치, 콘텐츠 상태 등) https://developer.mozilla.org/ko/docs/Web/CSS...", "content": "Pseudo Class (가짜 클래스, 의사 클래스, 가상 클래스, 추상 클래스) : pseudo class hover, checked 등이 해당. 외부 인자와 관련된 경우에도 스타일 적용할 수 있음. (마우스 위치, 콘텐츠 상태 등) https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-classes Pseudo Element (가짜 요소, 의사 요소, 가상 요소, 추상 요소) :: pseudo element after, before 등이 해당. 선택한 요소의 일부분에만 스타일을 입힐 수 있음. https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements Iass, Pass, SassIass(Infrastructure as a Service) 서버, 네트워크 등의 인프라를 빌려주는 서비스 OS, 미들웨어를 사용자가 직접 설치 ex) AWS ES2, S3Pass(Platform as a Service) 앱 설계, 개발, 테스트, 배포, 호스팅 포함 모든 자원을 빌려주는 서비스 개발, 운영 환경을 포함한 플렛폼 제공 사용자는 어플리케이션, 서비스 개발에 집중할 수 있음. ex) MS AzureSaas(Software as a Service) 클라우드를 통해 소프트웨어를 제공 설치, 전환과정 없이 클라우드에 있는 앱, 서비스를 인터넷을 통해 제공받음. Google Docs궁금한 점 - ‘Amazon Lightsail’이나 ‘Oracle Cloud’는 Iass일까? Pass일까? 서버 뿐만 아니라 OS의 자동 설치, 호스팅, 모든 자원을 빌려주며 개발 및 운영 환경을 위한 소프트웨어까지 제공해 주고 있으므로 Iass, Pass, Saas를 포괄하고 있는 클라우드 컴퓨팅 플랫폼(Cloud computing platform)이라고 할 수 있다.Reference https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-classes https://developer.mozilla.org/ko/docs/Web/CSS/Pseudo-elements https://jsj0903.tistory.com/5 https://iq-faq.com/en/Q%26A/page=e5ec03f0c175fbe8950bb23b1cd1e067" }, { "title": "Firebase - Firestore Database 가져오기, 쓰기", "url": "/posts/TIL_firebase-220305/", "categories": "TIL, Firebase, JavaScript", "tags": "", "date": "2022-03-05 00:00:00 +0900", "snippet": "들어가기 공식 문서에 너무 잘 정리가 되어있지만 완전 처음 사용할 때 헛갈렸던 부분이 있어서 정리 웹 버전 9 (modular) 기준데이터 쓰기 (혹은 덮어쓰기)set() 메서드 setDoc()을 사용함. 문서가 있으면 덮어씌움 문서가 없다면 새로 생성import { doc, setDoc } from \"firebase/firestore\";//...", "content": "들어가기 공식 문서에 너무 잘 정리가 되어있지만 완전 처음 사용할 때 헛갈렸던 부분이 있어서 정리 웹 버전 9 (modular) 기준데이터 쓰기 (혹은 덮어쓰기)set() 메서드 setDoc()을 사용함. 문서가 있으면 덮어씌움 문서가 없다면 새로 생성import { doc, setDoc } from \"firebase/firestore\";// Add a new document in collection \"cities\"await setDoc(doc(db, \"cities\", \"LA\"), { name: \"Los Angeles\", state: \"CA\", country: \"USA\"}); doc() 메서드 가장 마지막에 있는 인자가 문서의 이름이 됨. 위 예제로 따지면 아래와 같은 데이터 구조가 됨.- cities (root) -LA (cities/LA) 데이터를 더 깊게 넣으려면 뒤를 계속 추가하면 됨. ex) doc(db, \"abc\", \"abc_in\", 'abc_in_in', 'post_id') 이런식으로 계속 깊게 넣어줄 수 있음.문서의 ID를 자동으로 추가해서 데이터 쓰기 이때는 setDoc()이 아니고 collection과 addDoc() 메서드를 사용.import { collection, addDoc } from \"firebase/firestore\";// Add a new document with a generated id.const docRef = await addDoc(collection(db, \"cities\"), { name: \"Seoul\", country: \"Korea\"});console.log(\"Document written with ID: \", docRef.id); 위 코드의 경우 cities 안에 자동으로 생성된 ID로 문서가 생성됨. ID를 자동으로 생성한 경우 자동 정렬을 지원하지 않기 때문에 타임스템프 값을 추가해야 함.데이터 읽어오기get() 메서드 (단일 데이터) doc(), getDoc() 메서드를 사용const ref = getDoc(doc(db, \"Cities\", \"ID\"));console.log(ref.data()) // 데이터 값이 객체로 나옴.데이터 리스트 가져오기 getDocs() : 문서 리스트 가져오기 orderBy : 정렬 collection : 컬렉션const ref = getDocs(collection(db, \"Cities\"), orderBy(\"date\")); Cities안에 있는 데이터들을 \"date\" 기준으로 정리해서 불러오는 예시 코드" }, { "title": "'플래닝 포커'로 프로젝트 예상 시간 계산하기", "url": "/posts/TIL_planning_poker/", "categories": "TIL, 협업, 프로젝트", "tags": "", "date": "2022-03-04 00:00:00 +0900", "snippet": "들어가기원티드 프리온보딩 코스에서 프로젝트를 진행하면서 정말 많은 회고를 했었다. 그 중에서 하나는 ‘왜 항상 밤을 새고 새벽 4시까지 작업하게 되는가?’였다.우리는 시간을 줄이기 위해 여러 방법을 생각했었는데 그 중에 첫 번째는 가장 중요한 기능을 우선적 구현하는 MVP(Minimum Viable Product) 개발하기 였다.그리고 각자 구현하는 ...", "content": "들어가기원티드 프리온보딩 코스에서 프로젝트를 진행하면서 정말 많은 회고를 했었다. 그 중에서 하나는 ‘왜 항상 밤을 새고 새벽 4시까지 작업하게 되는가?’였다.우리는 시간을 줄이기 위해 여러 방법을 생각했었는데 그 중에 첫 번째는 가장 중요한 기능을 우선적 구현하는 MVP(Minimum Viable Product) 개발하기 였다.그리고 각자 구현하는 데 실제로 시간이 얼마나 걸리는지 멤버들의 의견을 들어보고 객관적으로 시간을 측정하기 위해 플래닝 포커를 사용했다.플래닝 포커(Planning Poker)정의 어떤 일에 걸리는 시간을 추정하기 위한 합의 기반 기술(consensus-based technique)이다. 스크림 포커라고도 한다. James Grenning에 의해서 정의되었다고 한다. (Planning Poker, 2002.04)방법 숫자가 적힌 카드를 나열한다. (어플을 사용해도 된다.) 먼저 MVP 리스트를 만들었으면 같이 시간을 협의할 항목을 정한다. (항목별로 진행한다.) 항목을 정했으면 타이머를 설정하고 진행하는데 걸릴 시간을 생각한다. 생각한 시간과 동일한 숫자 카드를 선택한다. 타이머가 끝나면 모두가 동시에 카드를 보여준다. 서로 그 시간을 선택한 타당한 이유를 제시하며 프로젝트 작업 시간을 협의한다. 이때도 시간을 정해놓고 진행하며 일정 시간이 지나도 협의가 되지 않는 경우 숫자 카드를 선택하는 부분부터 다시 진행한다.장점 프로젝트 진행 시간에 대해 조금 더 객관적으로 측정할 수 있다. 개발자의 개발 능력과 코딩할 때 중요하게 생각하는 부분이 각자 다를 수 있는데, 그런 의견을 반영할 수 있다. 각 항목마다 협의를 진행했기 때문에 프로젝트 전체 시간에 대한 협의가 어느정도 이루어졌다고 볼 수 있다. 재밌다(⭐⭐️⭐️⭐️⭐️️)단점 내가 구현하지 않는 부분에 대해서 짧은 일정을 줄 수 있다. 플래닝 포커를 진행하는 시간이 길게 느껴질 수 있다. (약 1~2시간 정도)실제 경험 프로젝트 기간 내내 게더타운을 통해서 만났기 때문에 시간이 되었을 때 동시에 노션에 숫자를 적어서 진행했다. 프로젝트 전체 기간이 짧았기 때문에 카드 숫자의 단위는 1h로 정했다. 각자의 숫자에 대해서 설명하고 적절하다고 생각하는 값을 협의하여 정했다. 그 결과가 다음 사진과 같다. 조금 더 재밌게 진행하려면 어플을 사용하면 좋다.Referencehttps://tech.kakao.com/2020/09/08/planning-poker/https://techblog.woowahan.com/2548/https://bcho.tistory.com/1041" }, { "title": "Next.js - getStaticProps 정적 페이지 생성", "url": "/posts/TIL_next_getStaticProps/", "categories": "TIL, Next.js", "tags": "", "date": "2022-03-03 00:00:00 +0900", "snippet": "정적 페이지 만들기 Next.js 프레임워크에서는 3가지 렌더링 방식이 있다. 정적 생성 SSR CSR 일반적으로 Next.js에서 데이터를 가져오는 메서드 없이 컴포넌트를 만들면 정적 페이지가 생성된다. 하지만 데이터를 가져와야 하는 경우 getStaticProps, getStaticPaths를 사용...", "content": "정적 페이지 만들기 Next.js 프레임워크에서는 3가지 렌더링 방식이 있다. 정적 생성 SSR CSR 일반적으로 Next.js에서 데이터를 가져오는 메서드 없이 컴포넌트를 만들면 정적 페이지가 생성된다. 하지만 데이터를 가져와야 하는 경우 getStaticProps, getStaticPaths를 사용해야 한다. 나의 경우 코드 리펙터링을 할 때 데이터를 가져와야 했으므로 getStaticProps나 getStaticPaths 둘 중에서 하나를 사용해야 했는데 getStaticProps를 사용했다.getStaticProps와 getStaticPathsgetStaticProps 빌드 시 값이 고정되어 빌드 이후에는 수정이 불가능하다.getStaticPaths 동적 라우팅과 getStaticProps를 동시에 원할 때 사용한다.getStaticProps 사용하기 리펙터링을 하는 부분 안에서 따로 라우팅을 다시 사용하는 일이 없어서 getStaticProps를 사용했다. 먼저 기존에는 API 값을 아래와 같이 가져왔었다.import { get } from 'apis/requestAPIs/contacts';const Contacts = () =&gt; { const [contactType, setContactType] = useState&lt;ContactType[]&gt;([]); const [qaPurchase, setQaPurchase] = useState&lt;QaItems[]&gt;([]); const [qaSale, setQaSale] = useState&lt;QaItems[]&gt;([]); useEffect(() =&gt; { get .ContactType() .then(res =&gt; setContactType(res.qaTypes)) .catch(e =&gt; console.error(e)); get .QaPurchase() .then(res =&gt; setQaPurchase(res.qas)) .catch(e =&gt; console.error(e)); get .QaSale() .then(res =&gt; setQaSale(res.qas)) .catch(e =&gt; console.error(e)); }, []);}export default Contacts getStaticProps를 사용하기 위해서 공식 문서에 있는 것처럼 최하단에 다음과 같이 추가한다.export async function getStaticProps() { const contactType = await get.ContactType(); const qaPurchase = await get.QaPurchase(); const qaSale = await get.QaSale(); return { props: { contactType: contactType.qaTypes, qaPurchase: qaPurchase.qas, qaSale: qaSale.qas, } }} getStaticProps에서 props로 반환을 했을 때 그 값들을 바로 컴포넌트에서 불러올 수 있다.const Contacts = ({ contactType, qaPurchase, qaSale }: ContactsAPIType) =&gt; {} 이렇게 불러와서 사용하면 된다. 정적 페이지 처리는 Next.js가 알아서 해준다.Referencehttps://nextjs.org/docs/basic-features/data-fetching/get-static-propshttps://velog.io/@devstone/Next.js-100-활용하기-feat.-initialProps-webpack-storybook" }, { "title": "instanceof, DOM", "url": "/posts/TIL_instanceof_dom/", "categories": "TIL, HTML, JavaScript, TypeScript", "tags": "", "date": "2022-03-02 00:00:00 +0900", "snippet": "들어가기&lt;M.MUITableRow hover={hover} {...(stickyTop !== undefined &amp;&amp; { sx: { position: 'sticky', zIndex: 1, top: stickyTop, ...sx }, })} onClick={event =&gt; { ...", "content": "들어가기&lt;M.MUITableRow hover={hover} {...(stickyTop !== undefined &amp;&amp; { sx: { position: 'sticky', zIndex: 1, top: stickyTop, ...sx }, })} onClick={event =&gt; { isHeader ? onClickHandler?.() : onClickHandler?.(order.orderId); modalHandler?.(order.id); if (event.target instanceof HTMLElement) { console.log(event.target.nodeName); } // console.log((event.target as Element).nodeName); }} &gt;이벤트 클릭 target을 받아와서 클릭하는 element에 따라 다른 handler를 지정하고자 event.target을 사용했는데 여기에 타입이 선언되지 않았다는 에러가 계속 나왔다.구글 검색한 결과 instanceof HTMLElement을 넣으면 타입 에러가 발생하지 않는 다는 것이었는데 왜 그렇게 되는 지 궁금해서 instanceof에 대해서 그리고 DOM구조에 대해서 찾아봤다.프로토타입(Prototype) 프로토타입은 객체 간 상속을 구현하기 위해 사용instanceof 연산자 개체가 특정 클래스의 인스턴스인지 boolean값으로 반환하는 비교 연산자객체 instanceof 생성자 함수 우측에 생성자 함수의 prototype에 바인딩된 객체가 좌측 객체의 프로토타입 체인 상에 존재하면 true로 평가됨.if (event.target instanceof HTMLElement) { console.log(event.target.nodeName); } 따라서 HTMLElement 노드 안에 event.target이 있었기 때문에 true가 되어서 사용 가능하게 됨.타입 단언 as 지금 이것의 타입은 내가 생각하는 그것이다. 컴파일러의 추론과 상관없이 내가 타입을 단언하는 경우에 사용. 타입 단언은 &lt;Element&gt;event.target의 형식으로도 사용할 수 있음. 하지만 이 상황에서는 tsx의 태그 문법과 비슷해서 헛갈릴 수가 있다. console.log((event.target as Element).nodeName); 사실 타입 문제 해결 방법에서 as를 사용한 방법이 가장 처음으로 나와서 사용했는데 알고 보니 내가 타입 단언하는 경우에 사용하는 것이기 때문에 위 코드에서는 조금 위험하다고 생각DOM출처 : https://ko.javascript.info/basic-dom-node-properties 위 크림으로 관계를 간단하게 설명할 수 있음. 가장 상위에 EventTarget이 있음. EventTarget과 Node는 ‘추상(abstract)’ 클래스이기 때문에 객체가 실제로 만들어지지 않음. (그래서 위 코드에서 as Node라고 했을 때는 에러가 났었음.) Element는 DOM요소를 위한 베이스 클래스 QuerySelector같은 탐색을 도와주는 프로퍼티나 메서드를 기반으로 함. SVGElement, HTMLElement, XMLElement의 클래스 베이스 역할도 함. HTMLElement는 HTML요소의 베이스 역할을 하는 클래스 여기에서 언급한 것 이외에도 많은 클래스들이 있음.alert( document.body instanceof HTMLBodyElement ); // truealert( document.body instanceof HTMLElement ); // truealert( document.body instanceof Element ); // truealert( document.body instanceof Node ); // truealert( document.body instanceof EventTarget ); // trueReferencehttps://radlohead.gitbook.io/typescript-deep-dive/type-system/type-assertionhttps://velog.io/@dltjdwls100/TIL-Typescript-is와-as-의-차이점https://ko.javascript.info/basic-dom-node-properties" }, { "title": "Bubbling 방지하기와 주의점, Jest Unit Test", "url": "/posts/TIL_bubbling/", "categories": "TIL, JavaScript, TDD, Jest", "tags": "", "date": "2022-03-01 00:00:00 +0900", "snippet": "Bubbling 방지하기와 주의점 onClick 등의 이벤트에선 event.preventDefault()를 사용 하지만 지난 번에 정리한 것처럼 부모 엘리먼트에서 자식 엘리먼트로 상속되는 이벤트의 경우 event.stopPropagation()를 사용 (a태그 등) 하지만 event.stopPropagation()의 경우 위쪽으로 일어나는 버블링...", "content": "Bubbling 방지하기와 주의점 onClick 등의 이벤트에선 event.preventDefault()를 사용 하지만 지난 번에 정리한 것처럼 부모 엘리먼트에서 자식 엘리먼트로 상속되는 이벤트의 경우 event.stopPropagation()를 사용 (a태그 등) 하지만 event.stopPropagation()의 경우 위쪽으로 일어나는 버블링만 막아주고, 다른 핸들러들이 동작하는 것은 막지 못함. 버블링 중지와 동시에 다른 핸들러 동작까지 막으려면 event.stopImmediatePropagation()를 사용. event.stopPropagation()을 사용해서 생길 수 있는 문제점 중첩 메뉴를 만들었을 때 상위 메뉴 클릭 이벤트 핸들러가 동작하지 않도록 stopPropagation을 사용함. 그런데 나중에 페이지 행동을 분석하기 위해 window 전역에 클릭 이벤트를 감지하도록 함. 하지만 stopPropagation 때문에 버블링을 막아놓은 영역은 분석이 작동하지 않게 됨 이런 영역을 Dead Zone이라고 함. 참고 : https://ko.javascript.info/bubbling-and-capturingJest Unit Test사용하기설치npm install --save-dev jest계산을 위한 sum.js라는 파일 생성function sum(a, b) { return a + b}module.exports = sum;테스트 파일 작성//sum.test.jsconst sum = require('./sum');test('1 + 2는 3과 같다', () =&gt; { expect(sum(1, 2)).toBe(3);}) package.json에 추가{ \"scripts\": { \"test\": \"jest\" }} npm test을 실행해서 통과하면 PASS라고 나옴출처 : https://jestjs.io" }, { "title": "debouncing & throttling", "url": "/posts/TIL_debouncing/", "categories": "TIL, JavaScript", "tags": "", "date": "2022-02-28 00:00:00 +0900", "snippet": "들어가기 지지난주에 했던 과제 구현 내용 중 Debounce와 자주 같이 소개되는 쓰로틀링과 연관해서 정리하면 좋을 것 같아서 이 주제로 다시 TIL을 남긴다.쓰로틀링과 디바운싱 프로그래밍 기법 중 하나로 다음과 같은 상황에서 사용함. 쓰로틀링 마지막 함수가 호출된 후 일정 시간이 지나기 전에는 다시 호출되지 않도록 하...", "content": "들어가기 지지난주에 했던 과제 구현 내용 중 Debounce와 자주 같이 소개되는 쓰로틀링과 연관해서 정리하면 좋을 것 같아서 이 주제로 다시 TIL을 남긴다.쓰로틀링과 디바운싱 프로그래밍 기법 중 하나로 다음과 같은 상황에서 사용함. 쓰로틀링 마지막 함수가 호출된 후 일정 시간이 지나기 전에는 다시 호출되지 않도록 하는 것 디바운싱 연속으로 호출되는 함수 중에서 마지막 함수나 첫 번째 함수만 호출되도록 하는 것 따라서 디바운싱은 지난 번에 구현했던 것처럼 검색어를 입력했을 때 enter를 누르지 않더라도 바로 event들이 대기하고 있다가 이벤트가 끝났을 때 1번만 실행되도록 하는 기법 쓰로틀링은 scroll 이벤트처럼 너무 많은 이벤트가 일어날 때 성능에 제한을 걸기 위해 사용." }, { "title": "Git Flow 모델", "url": "/posts/TIL_Git-Flow_medel/", "categories": "TIL, Git, GitFlow", "tags": "", "date": "2022-02-27 00:00:00 +0900", "snippet": "Git git tag 0.1 0.1 버전이라고 태그를 달아 놓는 방법 checkout할 때 b옵션 브랜치 생성과 동시에 체크아웃 git branch release/0.2 /0.2는 0.2버전을 준비하겠다고 달아 놓음. git merge –no-ff release/0...", "content": "Git git tag 0.1 0.1 버전이라고 태그를 달아 놓는 방법 checkout할 때 b옵션 브랜치 생성과 동시에 체크아웃 git branch release/0.2 /0.2는 0.2버전을 준비하겠다고 달아 놓음. git merge –no-ff release/0.2 커밋 메세지 남김 Git Flow Model 기능 단위로 브랜치를 만들어서 협업 시 프로젝트 관리를 용이하게 함. branch 관리 master : 출시하는 제품의 브랜치 develop : 개발용 브랜치 feature branches : 기능 개발용 브랜치들 release branhes : 릴리즈를 위한 브랜치 hotfixes : 긴급한 수정을 위한 브랜치 " }, { "title": "repeat, TypeScript Narrowing,", "url": "/posts/TIL_repeat_26/", "categories": "TIL, TypeScript, JavaScript, Narrowing", "tags": "", "date": "2022-02-26 00:00:00 +0900", "snippet": "String.prototype.repeat() 문자를 반복해서 새로운 문자열을 반환 '안녕'.repeat(3); //안녕안녕안녕 TypeScript Narrowing 타입을 좁혀 주어 더 안정적으로 코드를 체크할 수 있도록 하는 방법공식 문서에 다음과 같은 예제가 있다.function padLeft(padding: number | strin...", "content": "String.prototype.repeat() 문자를 반복해서 새로운 문자열을 반환 '안녕'.repeat(3); //안녕안녕안녕 TypeScript Narrowing 타입을 좁혀 주어 더 안정적으로 코드를 체크할 수 있도록 하는 방법공식 문서에 다음과 같은 예제가 있다.function padLeft(padding: number | string, input: string) { return \" \".repeat(padding) + input;}위 코드에서 repeat 안에 있는 padding은 다음과 같은 타입 에러가 발생한다. ‘string | number’ 형식의 인수는 ‘number’ 형식의 매개 변수에 할당될 수 없습니다. ‘string’ 형식은 ‘number’ 형식에 할당할 수 없습니다.ts(2345)padding은 number와 string인 유니언 타입으로 선언되었기 때문에 될 것 같지만, repeat안의 padding은 항상 number만 와야 하기 때문에 에러가 발생하는 것이다. 따라서 아래 코드와 같이 타입을 좁혀주면 에러가 발생하지 않는다.function padLeft(padding: number | string, input: string) { if (typeof padding === \"number\") { return \" \".repeat(padding) + input; } return padding + input;}typeof를 사용해서 padding이 number일 때만 \" \".repeat(padding) + input을 리턴하게 하면 padding은 number타입으로 정의되고 그 이후에 나오는 padding + input부분의 타입은 string으로 정의된다.typeof로 type 지키기 typeof가 리턴값으로 가질 수 있는 타입 “string” “number” “bigint” “boolean” “symbol” “undefined” “object” “function” " }, { "title": "220224,220225 - ClipBoard, React-Router v6", "url": "/posts/TIL_router-220224/", "categories": "TIL, JavaScript, React", "tags": "", "date": "2022-02-24 00:00:00 +0900", "snippet": "React-Router v6에서 History를 사용하려면 useHistory, History가 useNavigate로 바뀜. 사용법 import { useNavigate } from \"react-router-dom\"; const navigate = useNavigate(); navigate(`/${item.key}`); 2 번째...", "content": "React-Router v6에서 History를 사용하려면 useHistory, History가 useNavigate로 바뀜. 사용법 import { useNavigate } from \"react-router-dom\"; const navigate = useNavigate(); navigate(`/${item.key}`); 2 번째 prop은 넘겨주는 prop부모 태그의 이벤트 중지 event.stopPropagation()ClipBoard에 내용 복사하기 document.execcommand는 레거시 코드라 이제 사용하지 않음. Navigator.clipboard로 클립보드에 넘겨 줄 수 있음. 클립보드에 넣어줄 때는 다음과 같이 사용 navigator.clipboard.writeText(text).then(() =&gt; { window.alert(\"클립보드에 복사되었습니다.\"); }); 클립보드에 있는 값을 읽을 때는 다음과 같이 사용 navigator.clipboard.readText().then(clipText =&gt; window.alert(`읽은 값은 '${clipText}'입니다.`) " }, { "title": "CORS, 브라우저 렌더링, REST란?", "url": "/posts/TIL-CORS_RENDER/", "categories": "TIL, Git, Web, Css, CS", "tags": "", "date": "2022-02-23 00:00:00 +0900", "snippet": "#CORS (Cross Origin Resource Sharing)A 사이트에서 B사이트의 API로 정보를 요청할 때 리소스에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 것을 Cross Origin Resource Sharing, CORS라고 함. 프론트엔드 : 접근 방법, 도메인, 포트가 담겨 있는 Origin이라는 Header를 추가해...", "content": "#CORS (Cross Origin Resource Sharing)A 사이트에서 B사이트의 API로 정보를 요청할 때 리소스에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 것을 Cross Origin Resource Sharing, CORS라고 함. 프론트엔드 : 접근 방법, 도메인, 포트가 담겨 있는 Origin이라는 Header를 추가해서 요청을 보냄 백엔드 : 답장에 Access-Control-Allow-Origin 정보를 실어서 보냄. (저 안에는 프론트에서 요청하는 도메인이 포함되어 있어야 함.)#REST Representational State Transfer 리소스(자원)를 이름으로 구분하여 자원의 정보를 주고 받는 모든 것을 의미함. HTTP URI(Uniform Resource Identifier)를 통해 자원(Resource)를 명시하고, HTTP Method(POST, GET, PUT, DELETE, (PATCH))를 통해 해당 자원에 대한 CRUD Operation을 적용하는 것. GET: READ / POST: CREATE / PUT: UPDATE (정보 전체) / PATCH: UPDATE(정보 일부) / DELETE: DELETE 즉 HTTP Method를 통해 리소스를 처리하도록 설계된 구조를 말함. 각 요청이 어떤 동작이나 정보를 위한 것인지 요청 모습 자체로 추론 가능 URI : 주소 뒤에 있는 ?id=1 ← 이런 정보 CRUD : Create, Read, Update, Delete + HEAD: header 정보 조회 이것은 형식일 뿐임.#브라우저 렌더링 과정URL 입력 → 브라우저가 서버에게 요청/응답 → 로딩 → HTML태그를 DOM요소로 변환 → CSS를 CSSOM요소로 변환 → RenderTree 생성 → 각 요소의 크기 계산 → 브라우저에 출력(painting)&lt;img width=”683” alt=”렌더링 과정” src=”https://user-images.githubusercontent.com/90027202/155440646-0f8b7068-1b21-47ad-860b-ec952f8778b1.png”" }, { "title": "크로스 브라우징과 JQuery", "url": "/posts/TIL_cross_browsing/", "categories": "TIL, Git, Web, Css, CS", "tags": "", "date": "2022-02-22 00:00:00 +0900", "snippet": "#들어가기 이번에 IE8을 지원하는 웹사이트 만들기 프로젝트를 받고 깜짝 놀랐다. 지금까지 들은 강의에서는 JQuery는 이제 필요없다. 바닐라 자바스크립트는 ES6으로 배우면 된다고 했는데, 설마 JQuery를 배우게 될 줄은 몰랐다. 그런데 기존 레거시 코드를 React나 ES6 자바스크립트로 옮길 때 JQuery와 IE8에 대한 지식이 ...", "content": "#들어가기 이번에 IE8을 지원하는 웹사이트 만들기 프로젝트를 받고 깜짝 놀랐다. 지금까지 들은 강의에서는 JQuery는 이제 필요없다. 바닐라 자바스크립트는 ES6으로 배우면 된다고 했는데, 설마 JQuery를 배우게 될 줄은 몰랐다. 그런데 기존 레거시 코드를 React나 ES6 자바스크립트로 옮길 때 JQuery와 IE8에 대한 지식이 나중에 도움이 될 것이라고 생각했고 프로젝트를 진행하면서 JS, CSS, HTML의 기술은 정말 많이 발전했다고 느꼈다. 간단하게 느낀 점을 정리해보고자 한다.#JQuery - DOM을 쉽고 간편하게 조작할 수 있는 라이브러리이다. - IE8은 ES5를 지원하지 않아서 잘 사용하는 기능들 중에 안 되는 것이 정말 많은데, JQuery가 그 기능들을 모두 다 해준다. - DOM을 선택해서 값을 수정하는 것을 쉽게 해준다. - $() &lt;- 이렇게 선택하면 끝 - IE8에서 이동 애니메이션을 지원하지 않는데 그것마저 JQuery가 쉽게 지원해준다. - 그래서 그 당시 많이 쓰던 라이브러리였던 것 같다.#IE8 - 지원하지 않는 것이 정말 많다. - border-radius 지원하지 않았다. - flex 지원하지 않았다. -&gt; 그래서 float를 사용했다. - 미디어 쿼리도 지원하지 않았다 -&gt; 여기는 JS와 JQuery의 도움을 받았다. - 시맨틱 태그도 지원하지 않는다. (접근성은…? ㅠㅠ)#느낀점 IE8를 지원하면서 쉽게 코드를 작성하기 위해서는 JQuery가 최선의 방법이라고 느꼈다. IE8과 크로스 브라우징을 지원하기 위해서 ES5 이전의 자바스크립트를 사용해야 했다. 여기에서는 querySelector도 사용할 수 없고, css로서도 미디어 쿼리를 지원하지 않아서 자바스크립트로 하나 하나 코딩해야 했다. 하지만 JQuery에서는 querySelector를 사용하는 것처럼 $()를 사용해서 스타일을 넣을 수 있고 animate 라고 넣는 것 만으로도 간단하게 스크롤 애니메이션도 간편하게 넣을 수 있었다. JQuery의 기능은 HTML5, CSS3, ES6으로 쉽게 구현할 수 있다. JQuery에서 사용한 모든 기능이 바닐라 자바스크립트와 현재 HTML5, CSS3로 구현 가능한 것이었다. 따라서 현재 많이 이용하는 크롬 브라우저에서는 JQuery를 일부러 사용할 이유가 없다고 느꼈다. module화를 하지 못했을 때 협업이 어렵다. webpack같은 것을 사용할 수 없는 상황이라 JS도 모듈화를 하지 못했고, 특히 html 파일은 모두가 공동으로 작업하면서, 코드가 꼬이는 등의 문제로 불편했다. 또한, 코드를 잘못 수정할 수 있는 위험도 있어서 각 부분을 module로 나눠서 작업하는 것이 협업에서 중요하다고 느꼈다. 시맨틱 태그를 사용할 수 없어서 아쉬웠다. html5에 있는 시맨틱 태그를 IE가 지원하지 않아서 div로 모두 구성해야 하는 점이 아쉬웠다. " }, { "title": "git revert, reset, web", "url": "/posts/TIL_git_web/", "categories": "TIL, Git, Web, Css, CS", "tags": "", "date": "2022-02-21 00:00:00 +0900", "snippet": "git revert와 reset의 차이 reset: 이전 상태로 돌려버림 (타임머신) revert : 과거 특정한 사건들만 없던 일로 돌려 버림Web 폴리필(polyfill) : 웹 개발에서 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 말함. 이미지 스프라이트 로고, 아이콘 등의 파일을 한 개의 이미지로 담아 한 번만...", "content": "git revert와 reset의 차이 reset: 이전 상태로 돌려버림 (타임머신) revert : 과거 특정한 사건들만 없던 일로 돌려 버림Web 폴리필(polyfill) : 웹 개발에서 지원하지 않는 웹 브라우저 상의 기능을 구현하는 코드를 말함. 이미지 스프라이트 로고, 아이콘 등의 파일을 한 개의 이미지로 담아 한 번만 로딩하는 방식의 최적화 방법 쉽게 사용할 수 있는 꿀팁 사이트 http://www.spritecow.com 블로킹(Blocking) 자신의 수행결과가 끝날 때까지 제어권을 갖고 있는 것 " }, { "title": "pre태그, fit-content", "url": "/posts/TIL_pre/", "categories": "TIL, HTML, CSS", "tags": "", "date": "2022-02-20 00:00:00 +0900", "snippet": "pre 내용 상의 enter, space 등이 그대로 유지되는 태그&lt;pre&gt;그대여 그대여오늘은 우리 같이 걸어요&lt;/pre&gt;fit-content html의 넓이가 100%인데 밑에 있는 content가 100% 이상의 값을 가지고 있어서 가로 스크롤할 때 네비게이션이 끊겨 버리는 경우에 사용하는 스타일 짤리는 네비게이션 쪽에 ...", "content": "pre 내용 상의 enter, space 등이 그대로 유지되는 태그&lt;pre&gt;그대여 그대여오늘은 우리 같이 걸어요&lt;/pre&gt;fit-content html의 넓이가 100%인데 밑에 있는 content가 100% 이상의 값을 가지고 있어서 가로 스크롤할 때 네비게이션이 끊겨 버리는 경우에 사용하는 스타일 짤리는 네비게이션 쪽에 style=\"width: fit-content\"; 이렇게 삽입" }, { "title": "Debounce, MUI 사용법", "url": "/posts/TIL_debounce_MUI/", "categories": "TIL, JavaScript, React, TypeScript, Merterial-UI", "tags": "", "date": "2022-02-18 00:00:00 +0900", "snippet": "Debounce 연속으로 발생하는 이벤트를 제어하기 위해서 사용함. 이번 프로젝트에서 onChange로 검색 창을 구현하는데 실시간으로 변하는 값의 최적화 때문에 사용. useDebounce라는 커스텀 훅을 만들어서 값이 입력된 후 일정 시간이 지났을 때 처리하는 방식으로 만들 수 있음.typeScriptimport { useEffect, use...", "content": "Debounce 연속으로 발생하는 이벤트를 제어하기 위해서 사용함. 이번 프로젝트에서 onChange로 검색 창을 구현하는데 실시간으로 변하는 값의 최적화 때문에 사용. useDebounce라는 커스텀 훅을 만들어서 값이 입력된 후 일정 시간이 지났을 때 처리하는 방식으로 만들 수 있음.typeScriptimport { useEffect, useState } from 'react'export function useDebounce&lt;T&gt;(value: T, delay?: number): T { const [debouncedValue, setDebouncedValue] = useState&lt;T&gt;(value) useEffect(() =&gt; { const timer = setTimeout(() =&gt; setDebouncedValue(value), delay || 500) return () =&gt; { clearTimeout(timer) } }, [value, delay]) return debouncedValue}MUI 사용법 mui를 import해서 사용 styled component 처럼 커스텀해서 사용할 수 있음 커스텀할 때 모양은 styled 컴포넌트랑 조금 다른 데 아래와 같음import { styled } from '@mui/material/styles';import { InputBase } from '@mui/material';export const SearchBar = styled(InputBase)` width: 100%; color: #252525;`;" }, { "title": "Next, Atomic 디자인 패턴, 라이브러리 사용", "url": "/posts/TIL_Promise/", "categories": "TIL, JavaScript, DesignPatten, Library", "tags": "", "date": "2022-02-17 00:00:00 +0900", "snippet": "NEXT pages에는 component를 import만 (컴포넌트들이 한 눈에 들어올 수 있도록) components에 페이지의 모든 컴포넌트를 정리. API 호출할 때 SSR, CSR 어디에서 할 지 고민해보고 구현하면 좋음. useSWR 이미 가져온 것은 캐시에서 응답하고 아니면 새로 가져오는 것인데 이 훅은 전부 Clie...", "content": "NEXT pages에는 component를 import만 (컴포넌트들이 한 눈에 들어올 수 있도록) components에 페이지의 모든 컴포넌트를 정리. API 호출할 때 SSR, CSR 어디에서 할 지 고민해보고 구현하면 좋음. useSWR 이미 가져온 것은 캐시에서 응답하고 아니면 새로 가져오는 것인데 이 훅은 전부 Client Side Rednering이기 때문에 SSR으로 구현해야 하는 부분은 안 쓰는 것이 좋음. getServerSideProps를 썼을 때 페이지 로딩이 많이 느려짐. 그래서 대부분 getStaticProps와 CSR을 조합해서 쓰는 방식을 많이 씀. 데이터 호출 메서드는 3개를 사용 getStaticProps : api를 호출하고 데이터를 응답 받아서 HTML을 완성하는 정적 생성 getStaticPath : 빌드 시점에서 api호출하고 데이터를 응답받아 정적으로 생성 getServerSideProps : 페이지 접근 요청이 있을 때마다 서버에서 호출 Atomic 디자인 패턴 디자이너가 폴더 구조에 따라서 Figma에 디자인을 제시할 때 좋다.라이브러리 애니메이션에서 고려해야할 부분이 많은데 라이브러리를 사용하면 더 빨리 개발할 수 있다. 주니어 때는 라이브러리를 잘 활용하는 것도 실력이다." }, { "title": "Next, Styled Component, TypeScript", "url": "/posts/TIL_NEXT_STYLED-COMPONENT/", "categories": "TIL, Style, Next, Web, TypeScript", "tags": "", "date": "2022-02-15 00:00:00 +0900", "snippet": " 스타일드 컴포넌트 매크로를 쓰면 cra에서 컴포넌트의 파일명을 볼 수 있어서 디버깅하기에 좋다. next에서는 babel 설정 파일에서 해줄 수 있다. (pure) styled component와 typescript를 같이 쓸 때 theme의 타입 설정에서 타입 대신 해당 값을 써주면 나중에 테마를 볼러올 때 조금 ...", "content": " 스타일드 컴포넌트 매크로를 쓰면 cra에서 컴포넌트의 파일명을 볼 수 있어서 디버깅하기에 좋다. next에서는 babel 설정 파일에서 해줄 수 있다. (pure) styled component와 typescript를 같이 쓸 때 theme의 타입 설정에서 타입 대신 해당 값을 써주면 나중에 테마를 볼러올 때 조금 더 직관적으로 내용을 볼 수 있다. robots.txt를 통해 크롤러가 홈페이지 정보를 가져가거나 가져가지 못하게 설정할 수 있다. next도 cra처럼 next creat app으로 간단하게 세팅할 수 있다. " } ]
